<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Running_snail's Blog]]></title>
  <subtitle><![CDATA[Some notes about Web Front-End and others]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://snailsky.me/"/>
  <updated>2014-07-26T10:25:36.663Z</updated>
  <id>http://snailsky.me/</id>
  
  <author>
    <name><![CDATA[running_snail]]></name>
    <email><![CDATA[505324327@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[那些年被我们误用的CSS选择器]]></title>
    <link href="http://snailsky.me/2014/07/22/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%A2%AB%E6%88%91%E4%BB%AC%E8%AF%AF%E7%94%A8%E7%9A%84CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://snailsky.me/2014/07/22/那些年被我们误用的CSS选择器/</id>
    <published>2014-07-22T14:57:11.000Z</published>
    <updated>2014-07-25T02:13:52.000Z</updated>
    <content type="html"><![CDATA[<p>曾几何时，我天真的认为“选择器肯定是越详细，层数越多越好呗”。现在觉得自己以前真是图样图森破…<br>谨以此文，祭奠那些被我误用的CSS, orz。<br>此文重在讨论<em>如何书写高效的CSS选择器</em>。如有错误，欢迎指正，O(∩_∩)O</p>
<hr>
<h2 id="浏览如何识别选择器？">浏览如何识别选择器？</h2>
<p>“浏览器读取选择器的顺序是由右到左进行”—<a href="http://css-tricks.com/efficiently-rendering-css/" target="_blank">《Efficiently Rendering CSS》Chris Coyier</a></p>
<p>例如：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">ul</span> &gt; <span class="tag">li</span> <span class="tag">a</span><span class="attr_selector">[title="home"]</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure><br>浏览器将首先解释 a[title=”home”]。这个最先解释选择器是最后被选择的元素的“关键选择器”。<br><br>再如：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">a</span> <span class="tag">img</span>, <span class="tag">div</span> &gt; <span class="tag">p</span>, <span class="tag">h1</span> + <span class="attr_selector">[title]</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure><br>此处关键选择器为 img，p，title<br><br>关键选择器示例：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="id">#main-navigation</span> <span class="rules">{<span class="rule">…}</span></span>            <span class="comment">/* ID (Fastest) */</span>
<span class="tag">body</span><span class="class">.home</span> <span class="id">#page-wrap</span> <span class="rules">{<span class="rule">…}</span></span>        <span class="comment">/* ID */</span>
<span class="class">.main-navigation</span> <span class="rules">{<span class="rule">…}</span></span>            <span class="comment">/* Class */</span>
<span class="tag">ul</span> <span class="tag">li</span> <span class="tag">a</span><span class="class">.current</span> <span class="rules">{<span class="rule">…}</span></span>             <span class="comment">/* Class *
ul {…}                          /* Tag */</span>
<span class="tag">ul</span> <span class="tag">li</span> <span class="tag">a</span> <span class="rules">{<span class="rule">…}</span></span>                     <span class="comment">/* Tag */</span>
* <span class="rules">{<span class="rule">…}</span></span>                           <span class="comment">/* Universal (Slowest) */</span>
<span class="id">#content</span> <span class="attr_selector">[title='home']</span> <span class="rules">{<span class="rule">…}</span></span>     <span class="comment">/* Universal */</span>
</pre></td></tr></table></figure>

<p><em>越具体的关键选择器，其性能越高。 </em></p>
<h2 id="如何写有效率的CSS选择器？">如何写有效率的CSS选择器？</h2>
<h3 id="选择器效率排序">选择器效率排序</h3>
<p>选择器效率从高到低排列如下</p>
<ul>
<li>id选择器（#myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div,h1,p）</li>
<li>相邻选择器（h1+p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（*）</li>
<li>属性选择器（a[rel=”external”]）</li>
<li>伪类选择器（a:hover,li:nth-child）</li>
</ul>
<h3 id="一些写高效CSS选择器的规则">一些写高效CSS选择器的规则</h3>
<h4 id="不要在ID选择器前加标签名或类">不要在ID选择器前加标签名或类</h4>
<p>如果一个规则的关键选择器是ID选择器，不要在其前面加上标签名或类名。因为ID是唯一的加上一个标签名会降低匹配速度。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">button</span><span class="id">#backButton</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#backButton</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>



<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.menu-left</span><span class="id">#newMenuIcon</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#newMenuIcon</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<h4 id="不要在类前加标签名">不要在类前加标签名</h4>
<p>之前的观念依然适用，虽然类可在同个页面中被使用多次，但他们仍比标签稀罕。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">div</span>.indented <span class="tuple">{…}</span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD  (tag+class命名法 缺点是不够灵活，如果改了标签类名也要换)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>.<span class="keyword">div</span>-indented <span class="tuple">{…}</span>
</pre></td></tr></table></figure>

<ul>
<li>BEST  (语义化的类名使其更灵活)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.hierarchy-deep</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<h4 id="尽可能使用最具体的类别">尽可能使用最具体的类别</h4>
<ul>
<li>BAD (太多的规则导致查找速度变慢)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">a</span><span class="attr_selector">[target=_blank]</span> &gt; <span class="tag">p</span> &gt; <span class="tag">span</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">.</span>span<span class="attribute">-target</span><span class="attribute">-blank</span> {…}
</pre></td></tr></table></figure>

<h4 id="避免使用后代选择器">避免使用后代选择器</h4>
<p><em>后代选择器是CSS中代价最昂贵的选择器。</em>尤其是标签或是通配符选择器，它将昂贵的可怕。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">table</span> tbody tr th {…}
</pre></td></tr></table></figure>

<ul>
<li>BETTER,BUT STILL BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">table</span> &gt; tbody &gt; tr &gt; th {…}
</pre></td></tr></table></figure>

<h4 id="标签分类规则不应该包含子元素选择器">标签分类规则不应该包含子元素选择器</h4>
<p>避免在标签类型规则使用子元素选择器。这会使匹配时间增多。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">table</span> &gt; tbody &gt; tr &gt; th {…}
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>.th-<span class="built_in">table</span> {…}
</pre></td></tr></table></figure>

<h4 id="避免使用通配符选择器">避免使用通配符选择器</h4>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.selected</span> * <span class="rules">{<span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>浏览器会匹配文档中所有元素，然后分别向上逐级匹配class为selected的元素，<br>知道文档的根节点，因此匹配花销是非常大的，通常比开销最小的ID选择器高出1~3个数量级，所以应避免使用关键选择器是通配选择器的规则。</p>
<h4 id="避免使用单规则的选择器">避免使用单规则的选择器</h4>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.selected</span> <span class="attr_selector">[href=”#index”]</span> <span class="rules">{<span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>其匹配开销是非常大的，浏览器先匹配所有的元素，检查其是否有href属性并且herf属性值等于”#index”， 然后分别向上逐级匹配class为selected的元素，直到文档的根节点。所以应避免使用关键选择器是单规则属性选择器的规则。</p>
<h4 id="避免使用类正则的选择器">避免使用类正则的选择器</h4>
<p>CSS3添加了复杂的属性选择器，可以通过类正则表达式的方式对元素的属性值进行匹配。当然这些类型的选择器定是会影响性能的，正则表达式匹配会比基于类别的匹配会慢很多。大部分情况下我们应尽量避免使用 *=， |=， ^=， $=， 和 ~=语法的属性选择器。</p>
<h4 id="适当调整你的选择器">适当调整你的选择器</h4>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#main-navigation</span> <span class="tag">li</span> <span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">font-family</span>:<span class="value"> Georgia, Serif</span></span>; <span class="rule">}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD (如果你需要的只是改变字体，这样写可能更有效)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#main-navigation</span> <span class="rules">{ <span class="rule"><span class="attribute">font-family</span>:<span class="value"> Georgia, Serif</span></span>; <span class="rule">}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#nav</span> <span class="tag">li</span> <span class="tag">a</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD (如果要使用后代选择器，适当地缩小层级，降低CSS权重)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#nav</span> <span class="tag">a</span><span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<h3 id="笔者认为…">笔者认为…</h3>
<p>笔者认为虽然ID是最高效的选择器，不过如果把所有要选择的元素全都写上ID也是一件很蠢的事…<br>ID选择器权重太高，不存在任何可重用性，因此要尽量少用ID选择器。<br>笔者倾向于使用类选择器，简短且语义化的命名，同时书写模块化的CSS会使你的CSS更容易扩展和可重用。</p>
<hr>
<p>参考文献：<br><a href="http://www.w3cplus.com/css/css-selector-performance" target="_blank">[1] CSS选择器的优化</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Writing_efficient_CSS" target="_blank">[2] Writing efficient CSS</a><br><a href="http://css-tricks.com/efficiently-rendering-css/" target="_blank">[3] Efficiently Rendering CSS</a><br><a href="http://www.alloyteam.com/2012/10/high-performance-css/" target="_blank">[4] 高性能CSS</a><br><a href="http://www.w3cplus.com/css/css-specificity-things-you-should-know.html" target="_blank">[5] 你应该知道的一些事情——CSS权重</a></p>
]]></content>
    
    
      <category term="css" scheme="http://snailsky.me/tags/css/"/>
    
      <category term="性能优化" scheme="http://snailsky.me/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="选择器" scheme="http://snailsky.me/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CSS" scheme="http://snailsky.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grunt的配置及liveReload功能实例]]></title>
    <link href="http://snailsky.me/2014/07/19/grunt%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>http://snailsky.me/2014/07/19/grunt的配置及使用示例/</id>
    <published>2014-07-19T11:27:42.000Z</published>
    <updated>2014-07-19T12:23:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Grunt的介绍">Grunt的介绍</h2>
<p>Grunt是一个自动化的项目构建工具，配置好Grunt可以完成压缩，代码检查，单元测试等任务。C/C++有makefile，Java有Maven，Nodejs有grunt~</p>
<p>Grunt常用的插件有：<br>1).grunt-contrib-uglify：压缩js代码<br>2).grunt-contrib-concat：合并js文件<br>3).grunt-contrib-qunit：单元测试<br>4).grunt-contrib-jshint：js代码检查<br>5).grunt-contrib-watch：文件监控</p>
<p>关于这些插件的使用 <a href="http://blog.fens.me/nodejs-grunt-intro/" target="_blank">grunt让Nodejs规范起来</a> 这篇文章已经做了详细的介绍，此就不多说了。</p>
<h2 id="完整实例">完整实例</h2>
<p>此实例完成的工作为：保存代码后网页自动刷新，即时查看代码效果</p>
<p>安装 grunt-cli(先保证nodejs安装完成)<br><img src="/img/gruntConfig/1.png" alt="grunt"><br>grunt-cli 安装完成<br><img src="/img/gruntConfig/2.png" alt="grunt"></p>
<p>全局安装grunt<br><img src="/img/gruntConfig/3.png" alt="grunt"></p>
<p>grunt安装完成<br><img src="/img/gruntConfig/4.png" alt="grunt"></p>
<p>安装grunt到本项目中<br><img src="/img/gruntConfig/6.png" alt="grunt"></p>
<p>安装完毕<br><img src="/img/gruntConfig/7.png" alt="grunt"></p>
<p>—save-dev自动将依赖写入了package.json</p>
<p>执行grunt 发现报错了<br><img src="/img/gruntConfig/8.png" alt="grunt"></p>
<p>原来是缺少gruntfile.js</p>
<p>创建gruntfile.js<br>(此处是livereload功能的示例，需下载这个chrome扩展程序，配合使用，功能：可以保存代码后网页自动刷新，即时查看代码效果）</p>
<p><img src="/img/gruntConfig/9.png" alt="grunt"></p>
<p>gruntfile.js 内容：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>module.exports = <span class="function"><span class="keyword">function</span><span class="params">(grunt)</span> {</span>
 <span class="comment">// 项目配置(任务配置)</span>
 grunt.initConfig({
                   pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),
                   watch: {
                    client: {
                     files: [<span class="string">'public/**/**/*'</span>, <span class="string">'public/*'</span>,<span class="string">'public/**/*'</span>,<span class="string">'views/*'</span>],
                     options: {
                      livereload: <span class="literal">true</span>
                     }
                    }
                   }
                  });
 <span class="comment">// 加载插件</span>
 grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);
 <span class="comment">// 自定义任务 即需执行： grunt live</span>
 grunt.registerTask(<span class="string">'live'</span>, [<span class="string">'watch'</span>]);
};
</pre></td></tr></table></figure>


<p>再次执行 又报错了<br><img src="/img/gruntConfig/10.png" alt="grunt"></p>
<p>是没找到grunt-contrib-watch 这个包</p>
<p>下载这个包<br><img src="/img/gruntConfig/11.png" alt="grunt"></p>
<p>下载完成<br><img src="/img/gruntConfig/12.png" alt="grunt"></p>
<p>再次执行grunt<br><img src="/img/gruntConfig/13.png" alt="grunt"></p>
<p>我们回来看下代码，发现 default 任务没有注册 ，<br>而我们自定义了live任务：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>grunt.registerTask(<span class="string">'live'</span>, [<span class="string">'watch'</span>]);
</pre></td></tr></table></figure>

<p>你现在可以执行 grunt live 来执行这个任务<br><img src="/img/gruntConfig/15.png" alt="grunt"></p>
<p>你也可以创建一个default任务<br>如果创建default 这样创建 添加到gruntfile里</p>
<p><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// Default task(s).</span>
grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'watch'</span>]);
</pre></td></tr></table></figure><br>此时你可以 输入命令 grunt 或 grunt watch 来执行这个任务<br><img src="/img/gruntConfig/14.png" alt="grunt"></p>
<p>至此 启动你下载好的chrome livereload那个插件即可。<br>此时你就可以实时看代码效果，代码保存网页那边就刷新了，妈妈再也不用担心我玩命的按F5啦 ╮(╯▽╰)╭</p>
]]></content>
    
    
      <category term="grunt" scheme="http://snailsky.me/tags/grunt/"/>
    
      <category term="nodejs" scheme="http://snailsky.me/tags/nodejs/"/>
    
      <category term="安装" scheme="http://snailsky.me/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="实践笔记" scheme="http://snailsky.me/categories/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript学习笔记 - 模块化编程]]></title>
    <link href="http://snailsky.me/2014/07/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    <id>http://snailsky.me/2014/07/12/JavaScript学习笔记 - 模块化编程/</id>
    <published>2014-07-12T03:05:46.000Z</published>
    <updated>2014-07-14T08:15:08.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间，我急需这种模块化的方法来管理我的JavaScript代码<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">Javascript模块化编程</a>这一系列文章给我很大帮助，介绍得很通俗易懂，小伙伴们可以看看，我将在此文基础上记录一些我的笔记。</p>
<hr>
<h2 id="JavaScript模块简介">JavaScript模块简介</h2>
<p>JavaScript不是一种模块化编程语言，它不支持“类”（class），更不用说“模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用。）</p>
<p>我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。通过使用函数产生模块，我们几乎可以完全摒弃全局变量的使用，从而缓解这个JavaScript的最为糟糕的特性之一所带来的影响。</p>
<h2 id="JavaScript模块写法">JavaScript模块写法</h2>
<h3 id="立即执行函数">立即执行函数</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">0</span>;
    <span class="keyword">var</span> setCount = <span class="function"><span class="keyword">function</span><span class="params">(start)</span>{</span>
        count=start;
    }
    <span class="keyword">var</span> getCount = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> count;
    }
    <span class="keyword">return</span> {
        setCount:setCount,
        getCount:getCount,
    }
})();
</pre></td></tr></table></figure>

<p>本例是JavaScript模块的基本写法。使用到了<a href="http://snailsky.me/2014/07/11/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89/" target="_blank">闭包</a>。</p>
<p>此时外部代码无法读取内部的count变量。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(foo.count);   <span class="comment">//undefined</span>
</pre></td></tr></table></figure>

<h3 id="导入全局变量">导入全局变量</h3>
<p>把全局变量作为参数传递给一个立即执行函数，这样就完成了全局变量的导入，立即执行函数中可以使用此全局变量的方法，并可以修改（简化）全局变量的名称</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="list">(<span class="title">function</span> <span class="list">(<span class="title">$</span>, YAHOO)</span> <span class="collection">{
	// now have access to globals jQuery <span class="list">(<span class="title">as</span> $)</span> and YAHOO in this code
}</span><span class="list">(<span class="title">jQuery</span>, YAHOO)</span>)</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<h3 id="导出模块">导出模块</h3>
<p>通过在立即执行函数中返回一个Object，将模块导出到全局空间供其他模块使用</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> mod = {},
		privateVariable = <span class="number">1</span>;
	<span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span><span class="params">()</span> {</span>
		console.log(<span class="string">"this is a private method"</span>);
	}
	mod.moduleProperty = <span class="number">2</span>;
	mod.moduleMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		console.log(privateVariable);       
	};
    mod.callPrivateMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        privateMethod();
    }
	<span class="keyword">return</span> mod;
}());

<span class="comment">//test</span>
foo.moduleMethod(); <span class="comment">//output：1</span>
console.log(foo.moduleProperty);  <span class="comment">//output：2</span>
foo.callPrivateMethod(); <span class="comment">//output："this is a private method"</span>
foo.privateMethod(); <span class="comment">//undefined</span>
console.log(foo.privateVariable); <span class="comment">//undefined</span>
</pre></td></tr></table></figure>

<h3 id="方法的重写">方法的重写</h3>
<p>在“导出模块”例子基础上，重写他的moduleMethod方法..</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="params">(mod)</span> {</span>
	<span class="keyword">var</span> old_moduleMethod = mod.moduleMethod;
	mod.moduleMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		<span class="comment">// method override, has access to old through old_moduleMethod...</span>
        console.log(<span class="string">"this is already overridden"</span>);
	};
	<span class="keyword">return</span> mod;
}(foo));

<span class="comment">//test</span>
foo.moduleMethod(); <span class="comment">//output："this is already overridden"</span>
</pre></td></tr></table></figure>

<p>并且你可以在新方法中访问老方法，如果需要的话。</p>
<h3 id="克隆并重写方法">克隆并重写方法</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> cfoo = (<span class="function"><span class="keyword">function</span><span class="params">(old)</span>{</span>
    <span class="keyword">var</span> mod = {},
		key;
	<span class="keyword">for</span> (key <span class="keyword">in</span> old) {
		<span class="keyword">if</span> (old.hasOwnProperty(key)) {
			mod[key] = old[key];
		}
	}
	<span class="keyword">var</span> super_moduleMethod = old.moduleMethod;
	mod.moduleMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		<span class="comment">// override method on the clone, access to super through super_moduleMethod</span>
        console.log(<span class="string">"this is a override method on the clone"</span>);
	};
	<span class="keyword">return</span> mod;
})(foo);

<span class="comment">//test</span>
foo.moduleMethod(); <span class="comment">//output：1</span>
cfoo.moduleMethod(); <span class="comment">//output："this is a override method on the clone"</span>
cfoo.callPrivateMethod(); <span class="comment">//output："this is a private method"</span>
</pre></td></tr></table></figure>

<p>此可以克隆某个模块并可根据自己需要重写其方法。</p>
<h3 id="模块的继承">模块的继承</h3>
<p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块。在”立即执行函数”例子的基础上，继承bar。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span><span class="params">(mod)</span>{</span>
    mod.newFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"this is a new function"</span>);
    }
    <span class="keyword">return</span> mod;
})(bar);

<span class="comment">//test</span>
console.log(bar.getCount()); <span class="comment">//output：0</span>
bar.setCount(<span class="number">4</span>);
console.log(bar.getCount()); <span class="comment">//output：4</span>
bar.newFunc(); <span class="comment">//output："this is a new function"</span>
</pre></td></tr></table></figure>

<p>我们看到可以访问foo中的老函数和新方法。那他可不可以访问foo中的私有变量呢？</p>
<p>let’s have a try…</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span><span class="params">(mod)</span>{</span>
    mod.newFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"this is a new function"</span>);
    }
    mod.testFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(count);
        console.log(<span class="keyword">this</span>.count);
    }
    <span class="keyword">return</span> mod;
})(bar);

<span class="comment">//test</span>
bar.testFunc(); <span class="comment">//两种访问count方式，结果都是undefined，即说明这种方法访问不到父模块的私有变量</span>
</pre></td></tr></table></figure>

<p><em>注意</em>：这种方法是访问不到父模块的私有变量的。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象。可以用一下方式解决：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span><span class="params">(mod)</span>{</span>
    mod.newFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"this is a new function"</span>);
    }
    <span class="keyword">return</span> mod;
})(bar||{});
</pre></td></tr></table></figure>

<h2 id="模块应用-单例模式">模块应用-单例模式</h2>
<p>模块模式通常结合单例模式（Singleton Pattern）使用。JavaScript的单例就是用对象字面量表示法创建的对象，对象的属性值可以试数值或函数，并且属性值在该对象的生命周期中不会发生变化。</p>
<p>单例的最佳实践：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> Universe;
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>    
    <span class="keyword">var</span> instance;   
    Universe = <span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span> {</span>        
        <span class="keyword">if</span> (instance) {
            <span class="keyword">return</span> instance;
        }        
        instance = <span class="keyword">this</span>;        
        <span class="comment">// all the functionality</span>
        <span class="keyword">this</span>.start_time = <span class="number">0</span>;
        <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;
    };
}());
</pre></td></tr></table></figure>

<p>测试一下一以上代码：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">// testing</span>
<span class="built_in">var</span> uni <span class="subst">=</span> <span class="literal">new</span> Universe();
<span class="built_in">var</span> uni2 <span class="subst">=</span> <span class="literal">new</span> Universe();
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="subst">===</span>uni2); <span class="comment">//output：true</span>

<span class="comment">// adding to the prototype</span>
Universe<span class="built_in">.</span>prototype<span class="built_in">.</span>nothing <span class="subst">=</span> <span class="literal">true</span>;

<span class="built_in">var</span> uni <span class="subst">=</span> <span class="literal">new</span> Universe();

<span class="comment">// again adding to the prototype</span>
<span class="comment">// after the initial object is created</span>
Universe<span class="built_in">.</span>prototype<span class="built_in">.</span>everything <span class="subst">=</span> <span class="literal">true</span>;

<span class="built_in">var</span> uni2 <span class="subst">=</span> <span class="literal">new</span> Universe();

<span class="comment">// linked to the objects</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>nothing); <span class="comment">// output：true</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni2<span class="built_in">.</span>nothing); <span class="comment">// output：true</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>everything); <span class="comment">// output：true</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni2<span class="built_in">.</span>everything); <span class="comment">// output：true</span>

console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>constructor<span class="built_in">.</span>name); <span class="comment">// output："Universe"</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>constructor <span class="subst">===</span> Universe); <span class="comment">// output："Universe"</span>
</pre></td></tr></table></figure>

<p>我们发现new出来的两个Universe对象是同一个所以他们是同一个对象，实现了单例，且加进原型的属性在两个对象均可访问。</p>
<p>关于constructor：<br>constructor属性不影响任何JavaScript的内部属性。instanceof检测对象的原型链，通常你是无法修改的（不过某些引擎通过私有的<strong>proto</strong>属性暴露出来）。</p>
<p>constructor其实没有什么用处，只是JavaScript语言设计的历史遗留物。由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。不过，从编程习惯上，我们应该尽量让对象的constructor指向其构造函数，以维持这个惯例。</p>
<h2 id="模块的规范">模块的规范</h2>
<p>目前，通行的Javascript模块规范有：CommonJS（node.js应用此规范），AMD(异步模块定义)，CMD（通用模块定义）。<br>主要有两个Javascript库实现了AMD规范：require.js和curl.js。<br>实现了CMD规范：sea.js。</p>
<p>关于这些库和规范的讨论相关文章有：<br><a href="https://github.com/seajs/seajs/issues/277" target="_blank">seaJS与RequireJS的异同</a><br><a href="http://www.zhihu.com/question/20351507/answer/14859415" target="_blank">AMD 和 CMD 的区别有哪些？</a></p>
<p>先写到这，对于这些库，尚在了解中。等应用一阵再写相关的博文吧。</p>
<hr>
<p>参考文献：<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">[1] Javascript模块化编程</a><br><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank">[2] JavaScript Module Pattern: In-Depth</a><br><a href="http://book.douban.com/subject/2994925/" target="_blank">[3] JavaScript - The Good Parts</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/02/20/2352817.html" target="_blank">[4] 深入理解JavaScript系列（25）：设计模式之单例模式</a><br><a href="https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/singleton.html" target="_blank">[5] javascript-patterns  singleton</a></p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript学习笔记 - 闭包（closure）]]></title>
    <link href="http://snailsky.me/2014/07/11/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89/"/>
    <id>http://snailsky.me/2014/07/11/JavaScript学习笔记 - 闭包（closure）/</id>
    <published>2014-07-11T12:59:40.000Z</published>
    <updated>2014-07-26T10:24:23.000Z</updated>
    <content type="html"><![CDATA[<p>本文本着3个目的进行探究<br>1.闭包是什么<br>2.为什么要用闭包<br>3.闭包的应用场景<br>我的傻瓜式学习笔记，给自己备忘，也希望能帮助到一些人，如有错误欢迎指正。O(∩_∩)O~</p>
<hr>
<h2 id="为什么要用闭包？">为什么要用闭包？</h2>
<h3 id="作用域">作用域</h3>
<p>函数是JavaScript中唯一拥有自身作用域的结构。（JavaScript不支持块级作用域）<br>意味着定义在函数中的参数和变量在函数外部是不可见的，而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见。</p>
<p>一个值得注意的例子：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> a = <span class="number">3</span>,b = <span class="number">5</span>;
    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">var</span> b = <span class="number">7</span>,c = <span class="number">11</span>;
        <span class="comment">//此时，a为3，b为7，c为11。</span>
        a += b+c;
        <span class="comment">//此时，a为21，b为7，c为11。</span>
    };
    <span class="comment">//此时，a为3，b为5，而c还没有定义</span>
    bar();
    <span class="comment">//此时，a为21，b为5</span>
};
</pre></td></tr></table></figure>

<h4 id="函数访问全局变量">函数访问全局变量</h4>
<p>JavaScript中函数内部可以直接访问全局变量。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> n=<span class="number">999</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    console.log(n);
}

<span class="comment">//test</span>
f1(); <span class="comment">// 999</span>
</pre></td></tr></table></figure>

<p>函数外部无法读取函数内的局部变量。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> n=<span class="number">999</span>;
}

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> n=<span class="number">999</span>;
}
f1();

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<p><em>注意</em>：此时的n，如果声明时没有用var命令，在执行了声明它的函数后，事实上是产生了一个全局变量！</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    n=<span class="number">999</span>;
}

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">{
    n=999;
}</span>
<span class="title">f1</span><span class="params">()</span>;</span>

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// output：999</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> n=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">{
    n=999;
}</span>
<span class="title">f1</span><span class="params">()</span>;</span>

<span class="comment">//test</span>
console.log(n);    <span class="comment">// output：999</span>
</pre></td></tr></table></figure>

<h4 id="外部访问函数局部变量">外部访问函数局部变量</h4>
<p>正常情况下JavaScript无法获得函数内部的局部变量的值，可是我们有时需要获取，我们应该怎样做？</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
        console.log(count);
    }
}

<span class="comment">//test</span>
counter();  <span class="comment">//木有反应</span>
</pre></td></tr></table></figure>

<p>以上代码木有反应，因为我们执行了counter函数却没执行counter函数里面的个体函数哟..<br>我们在counter里面调用一下get();这样执行counter函数即执行了get函数。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
        console.log(count);
    }
    <span class="keyword">get</span>();
}

<span class="comment">//test</span>
counter();  <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>这样我们便访问到了counter的局部变量，哈哈，大功告成！…了吗？<br>我们这样做和一下代码有什么区别？！</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    console.log(count);
}

<span class="comment">//test</span>
counter();  <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>这样做行不通，我们另寻他径。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> count;
    }
    <span class="keyword">return</span> <span class="keyword">get</span>;
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo());    <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>我们返回了一个函数名get，当执行了counter函数后返回了counter函数内的get函数的引用并赋值给foo，在外面执行了foo()相当于调用了get()，我们获取到了局部变量count！！！~</p>
<p>以下例子更加灵活</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">return</span> count;
        }
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo.<span class="keyword">get</span>());    <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>这次我们return了一个对象字面量，在执行counter函数后返回了一个对象字面量并赋给一个foo变量，里面有个名为get的key，其value为一个匿名函数（是否是匿名并没有关系）。我们执行字面量中的get方法，得到了count。</p>
<p>我们希望能在一个函数中访问局部变量，完成更多的事，不仅仅是这一个用途而已。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">return</span> count;
        },
        increment:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            count++;
        }
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：5</span>
foo.increment();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：6</span>
</pre></td></tr></table></figure>

<p>以上例子也可以这么写：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
     <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
          <span class="keyword">return</span> count;
     }
     <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
         count++;
     }
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="keyword">get</span>,
        increment:increment
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：5</span>
foo.increment();
console.log(foo.<span class="keyword">get</span>());    <span class="comment">//output：6</span>
</pre></td></tr></table></figure>

<p>再改进一下，使他更有意义：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">(start)</span>{</span>
    <span class="keyword">var</span> count=start;
     <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
          <span class="keyword">return</span> count;
     }
     <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
         count++;
     }
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="keyword">get</span>,
        increment:increment
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter(<span class="number">4</span>);
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：4</span>
foo.increment();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>至此，我们已经应用到了闭包。<br>这个例子中的counter函数返回两个闭包，函数get和函数increment。这两个函数都维持着对外部作用域 counter 的引用，因此总可以访问此作用域内定义的变量 count。</p>
<p>以上例子，你还可以这样写</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">0</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">setCount</span><span class="params">(start)</span>{</span>
        count=start;
    }
     <span class="function"><span class="keyword">function</span> <span class="title">getCount</span><span class="params">()</span>{</span>
          <span class="keyword">return</span> count;
     }
     <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
         count++;
     }
    <span class="keyword">return</span> {
        setCount:setCount,
        getCount:getCount,
        increment:increment
    }
}());

<span class="comment">//test</span>
console.log(foo.getCount());   <span class="comment">//output：0</span>
foo.increment();
console.log(foo.getCount());   <span class="comment">//output：1</span>
<span class="comment">//重新设置count</span>
foo.setCount(<span class="number">4</span>);
console.log(foo.getCount());   <span class="comment">//output：4</span>
foo.increment();
console.log(foo.getCount());   <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>此处我们直接把调用函数后的结果赋值给foo，注意最后一行的()，成为立即执行函数。<br>之后我们可以直接使用foo.xx的方式来访问相关函数。<br>这也是JavaScript模块化编程的一种写法。</p>
<p>关于立即执行函数，以下两种写法均可，看个人习惯：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">//写法一</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">/* code */</span> } ());
<span class="comment">//写法二</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">/* code */</span> })();
</pre></td></tr></table></figure>

<p>(function(){}())是使用了强制运算符执行函数调用运算，(function(){})()是通过函数调用运算符操作函数引用。两者功能上是一致的，只是运算过程不同。</p>
<h2 id="闭包是什么？">闭包是什么？</h2>
<p>闭包是 JavaScript一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。 因为函数是JavaScript中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p>
<p>闭包在书中是这样被描述的：</p>
<p>闭包是函数和执行它的作用域组成的综合体<br>                        — 《JavaScript权威指南》<br>闭包是一种在函数内访问和操作外部变量的方式<br>所有的函数都是闭包<br>函数可以访问它被创建时的上下文环境，成为闭包<br>                        — 《JavaScript语言精粹》</p>
<p>内部函数比它的外部函数具有更长的生命周期</p>
<p>更简单的定义—<br>闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”<br>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h3 id="改变私有变量？">改变私有变量？</h3>
<p>我们能否在闭包外面改变私有变量呢？</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">(start)</span>{</span>
   <span class="keyword">var</span> count=start;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
         <span class="keyword">return</span> count;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
        count++;
    }
   <span class="keyword">return</span> {
       <span class="keyword">get</span>:<span class="keyword">get</span>,
       increment:increment
   }

ar foo=counter(<span class="number">4</span>);
oo.hack = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
   count = <span class="number">999</span>;
;

/test
onsole.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：4</span>
</pre></td></tr></table></figure>

<p>这种做法，答案是NO。foo.hack没有定义在counter作用域内，以上代码不会改变定义在counter作用域中的count值。</p>
<h3 id="闭包的用途">闭包的用途</h3>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<h2 id="使用闭包的注意点">使用闭包的注意点</h2>
<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h3 id="循环中的闭包">循环中的闭包</h3>
<p>一个常见的错误，出现在循环中使用闭包，假设我们需要在每次循环中访问循环序号</p>
<h4 id="例一:"><em>例一:</em></h4>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(i);
    }, <span class="number">1000</span>);
}
</pre></td></tr></table></figure>

<p>执行结果为：<br><img src="/img/closure/1.jpg" alt="closure"></p>
<p>上面的代码不会输出数字 0 到 9，而是会输出数字 10 十次。</p>
<p>当 console.log 被调用的时候，匿名函数保持对外部变量 i 的引用，此时 for循环已经结束， i 的值被修改成了 10.</p>
<p>为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。</p>
<h4 id="避免引用错误">避免引用错误</h4>
<p>为了正确的获得循环序号，最好使用匿名包裹器。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    (<span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(e);
        }, <span class="number">1000</span>);
    })(i);
}
</pre></td></tr></table></figure>

<p>执行结果为：<br><img src="/img/closure/2.jpg" alt="closure"></p>
<p>外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 e 变量就拥有了 i 的一个拷贝。</p>
<p>当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。</p>
<p>有另一个方法完成同样的工作；那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    setTimeout((<span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(e);
        }
    })(i), <span class="number">1000</span>)
}
</pre></td></tr></table></figure>

<p>执行结果为：<br><img src="/img/closure/3.jpg" alt="closure"></p>
<h4 id="例二:"><em>例二:</em></h4>
<p>糟糕的例子：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>var foo=<span class="function"><span class="keyword">function</span><span class="params">(nodes)</span>{</span>
    var <span class="built_in">i</span>;
    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;<span class="transposed_variable">nodes.</span><span class="built_in">length</span>; <span class="built_in">i</span>+=<span class="number">1</span>)<span class="cell">{
        node[i].onclick=function(e){
            console.log(i);
        }</span>;
    }
};
</pre></td></tr></table></figure>

<p>错误来源于在循环中创建函数，其本意是想传递给每个事件处理器一个唯一值(i)。但它未能达到目的，因为事件处理器函数绑定了变量i本身，而不是<br>函数在构造时的变量i的值。</p>
<h4 id="避免引用错误-1">避免引用错误</h4>
<p>创建一个辅助函数，改良后的例子：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>var foo=<span class="function"><span class="keyword">function</span><span class="params">(nodes)</span>{</span>
    var helper=<span class="function"><span class="keyword">function</span><span class="params">(i)</span>{</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
           <span class="transposed_variable">console.</span><span class="built_in">log</span>(<span class="built_in">i</span>);
        };
    };
    var <span class="built_in">i</span>;
    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;<span class="transposed_variable">nodes.</span><span class="built_in">length</span>; <span class="built_in">i</span>+=<span class="number">1</span>)<span class="cell">{
        node[i].onclick=helper(i);
    }</span>
};
</pre></td></tr></table></figure>

<p><em>避免在循环中创建函数</em>，在循环中创建函数，会导致错误，只会带来无谓的计算及引起混淆。<br>在循环之外创建一个辅助函数，让这个辅助函数再返回一个绑定了当前i值的函数，这样就不会导致混淆了。</p>
<hr>
<p>参考文献：<br><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank">[1] 学习Javascript闭包（Closure）</a><br><a href="http://book.douban.com/subject/2994925/" target="_blank">[2] JavaScript - The Good Parts</a><br><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.closures" target="_blank">[3] JavaScript 秘密花园 - 闭包和引用</a><br><a href="http://www.slideshare.net/lijing00333/javascript-12526041" target="_blank">[4] 潜力无限的编程语言JavaScript</a></p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[致将与前端技术渡过的宝贵假期]]></title>
    <link href="http://snailsky.me/2014/07/04/%E8%87%B4%E5%B0%86%E4%B8%8E%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%B8%A1%E8%BF%87%E7%9A%84%E5%AE%9D%E8%B4%B5%E5%81%87%E6%9C%9F/"/>
    <id>http://snailsky.me/2014/07/04/致将与前端技术渡过的宝贵假期/</id>
    <published>2014-07-04T03:04:13.000Z</published>
    <updated>2014-07-04T04:54:30.000Z</updated>
    <content type="html"><![CDATA[<p>今天心血来潮，在家呆着，怕自己没了激情，自己给自己鼓励一下  (╯▔▽▔)╯</p>
<p>　　博主是个宅女懒人，从小就是，放假从来都是一觉睡到大中午，下午昏昏沉沉的看电视到晚上，接着睡…啊 天…现在觉得过去的自己真是好口怕…</p>
<p>　　恐怕只有自己喜欢的事才肯花时间，并孜孜不倦…</p>
<p>　　比如说喜欢周笔畅这件事,10年了都…并且基本上她出席的所有节目都看过，所有专辑歌曲包括各种场合及节目中翻唱过的歌都会唱(“▔□▔)/(“▔□▔)/(“▔□▔)/再比如说曾经因为很喜欢一首歌里面的伴奏乐器的声音(那个乐器叫做ukulele，是个可爱的长得像小小的吉他的乐器)特意较深入地去了解这个乐器,后来一个哥哥买了，借给我玩，我还辛辛苦苦去网上扒琴谱，把这首歌弹会了…再比如说动漫，海贼王600多集我可一集没拉哦…等等..我貌似说的都是玩的  Σ(￣。￣ﾉ)ﾉ．．．是的，博主是个很爱玩的女汉纸…所以说经过20多年的观察，偶发现自己必须要从事一件自己喜欢的工作以此为乐才能做得好，而不想只是混口饭吃…</p>
<p>　　上课学习编程，老师讲课总是忍不住走神，如果是自己写代码倒是来了精神。自己写代码总是感觉干听着好玩多了…可是在用JAVA写增删改查，用JAVA框架SSH写增删改查，用EJB写增删改查之后，博主终于要吐了…博主开始觉得之前用C语言写ACM的题目时候真有趣…开始想念自己刚刚自学js那会儿写的俄罗斯方块的日子，每天都充满了期待。</p>
<p>　　这里只是自己的感受，不是说哪门语言好哪门语言不好，我相信不管用哪门语言写自己喜欢的东西不会觉得烦会觉得很有趣，而我也相信不管你用哪门语言无休止的狂写增删改查之后，也会想吐的…我从作业里面感到厌烦，我希望能自己开动脑筋做些有趣的东西，比如学JAVA为什么一定要做个系统，增删改查？我也可以自己做一个基于JAVA的小游戏，不过上课嘛随便做做就好，没有那些闲工夫，因为我还有实验室的工作。即使这样，苦中求乐，我还每次做系统都给自己一些挑战，比如说忍受不了丑丑的页面，花时间把它设计的好看些，再自己加个上传图片的功能，不用老师教的方法生成图表，用前端的画图表的库之类的。这样每次做的不光是增删改查，还有其他挑战，每次做了都感觉自己有所提升也就感觉上了这课自己没有浪费时间。</p>
<p>　　而js能实现各种酷炫的效果，让我很迷醉，虽然说js适应各种不同浏览器可能写法都不一样，这点真的有点恶心，不如说是IE恶心比较好？博主也懒得去理IE，劳资更喜欢移动web，因为不用去考虑那些个奇奇怪怪的事情。所以至今IE的兼容方面也没有什么研究(主啊，原谅我吧)，也许在需要的时候才去研究是最好的时机，反正我现在觉得研究那个是浪费时间。做组件的时候我仍然觉得js很好玩，虽然那时候自己写出的代码真的丑。</p>
<p>　　再后来认识了node.js我感觉我的天空一下子放亮了。从那之后开始也陆陆续续地接触到了新鲜的技术，喜欢新技术，很有趣。后来开始写node 和angular，开始使用grunt 感觉这些东西比JAVA那套东西要可爱得多。而且之前从来没有想过以后要从事什么职位，在那之后我想成为一名前端攻城狮…并想为了这个目标努力奋斗。</p>
<p>　　我认为”想”比什么都重要。</p>
<p>　　我的基础并不扎实，不管什么语言，我都不喜欢看书学，感觉很无聊，我就喜欢自己敲，管他对不对，遇到问题了就上网搜一下，这种狂放的学习方法很是符合我的性格O__O” 。但是既然想成为专业的人士肯定基础要牢一些才行，所以这个假期最主要的目标是多做东西，多补基础，我希望边学边在博客上写笔记，那是极好的，这样大概能督促我认真一点。做东西时也注意记录遇到的问题之类的，以前遇到那些问题由于自己没有记笔记的习惯，所以很可惜…没有记下你们…今后我会注意的~如果能做很多自己喜欢的东西出来是极好的。不要浪费时间才好。有时间还可以研究自己以前很好奇但是没用过的东西。希望有这个时间。</p>
<p>　　因为当初的喜欢，现在要付出加倍努力，成为优秀的码农= =　希望自己可以做到~从今天起到假期结束，我希望每天都可以看到充充实实的小！绿！点！You Can Do It ！！！ 加油！</p>
]]></content>
    
    
      <category term="感悟" scheme="http://snailsky.me/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="心情" scheme="http://snailsky.me/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="日记" scheme="http://snailsky.me/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="学习生活" scheme="http://snailsky.me/tags/%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    
      <category term="生活随笔" scheme="http://snailsky.me/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB的安装及简单使用示例]]></title>
    <link href="http://snailsky.me/2014/07/02/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>http://snailsky.me/2014/07/02/mongodb的安装及简单使用示例/</id>
    <published>2014-07-02T06:26:23.000Z</published>
    <updated>2014-07-02T09:34:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是MongoDB">什么是MongoDB</h2>
<p>MongoDB是介于传统数据库和NoSQL数据库之间的一种非关系型数据库。MongoDB使用c++实现，具有高可靠，高可用等优秀特性。<br>Mongo的官方网站地址是：<a href="http://www.mongodb.org/" target="_blank">http://www.mongodb.org/</a></p>
<h2 id="MongoDB的安装(windows下)">MongoDB的安装(windows下)</h2>
<p>在官方网站下载了MongoDB了之后，我们就可以进行MongoDB的安装工作了。<br>（以下截图来自在windows server 2003系统上面安装mongo过程中）</p>
<h3 id="1-安装包解压">1.安装包解压</h3>
<p>将mongo安装包解压放在D:/ 改名为mongodb<br><img src="/img/mongoInstall/mongodb1_1.png" alt="mongo的安装"></p>
<h3 id="2-新建存数据的文件夹">2.新建存数据的文件夹</h3>
<p>mongodb下新建文件夹db（随便叫什么都行）用来存mongo的数据<br><img src="/img/mongoInstall/mongodb1_2.png" alt="mongo的安装"></p>
<h3 id="3-运行mongo">3.运行mongo</h3>
<p>现在你已经可以运行mongo咯~<br><em>方法一</em><br>mongodb的bin目录下，shift+鼠标右键&gt;在此处打开命令窗口&gt;输入以下命令</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>mongod --dbpath D:<span class="command">\Mongodb</span><span class="command">\db</span>
</pre></td></tr></table></figure>

<p>这样就可以启动mongo了~</p>
<p><em>方法二</em><br>不过由于作者我是个懒虫，所以为了每次少输入这么个命令，所以就写了个bat文件，O(∩_∩)O哈哈~<br>在mongodb的bin文件夹下新建一个”快速启动.bat”<br><img src="/img/mongoInstall/mongodb1_3.png" alt="mongo的安装"><br>bat文件内容如下<br><img src="/img/mongoInstall/mongodb1_4.png" alt="mongo的安装"><br>保存，并双击”快速启动.bat”将看到以下界面，运行成功~<br><img src="/img/mongoInstall/mongodb1_5.png" alt="mongo的安装"><br>在浏览器输入：<a href="http://localhost:27017/" target="_blank">http://localhost:27017/</a><br>可以看到如下提示：<br>You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number</p>
<p>如此，MongoDB数据库服务已经成功启动了。</p>
<h2 id="MongoDB简单使用示例">MongoDB简单使用示例</h2>
<p>这里只做最简单的示范，如果有兴趣详细了解可以去看《MongoDB权威指南》这本书哟~</p>
<p>博主偶数据方面都偏爱使用可视化工具,使用起较方便( 其实是因为懒吧Σ(￣。￣ﾉ)ﾉ ),MongoDB我是用的可视化工具是Robomongo…</p>
<h3 id="创建新的database">创建新的database</h3>
<p>在你的connection（左上角可新建connection）上右键&gt;单击CreateDatabase&gt;输入数据库名字&gt;create 这样就创建完成了..<br>像这样：<br><img src="/img/mongoInstall/mongodb1_6.jpg" alt="robomongo的使用"><br>新建的数据库里啥都没有,首先偶们先来给他添一张表吧,右键数据库&gt;Open Shell 在右边框框里可输入命令</p>
<h3 id="创建新表">创建新表</h3>
<p>现在我们创建一张用户表users（包含字段“用户名”、“密码”、“注册时间”）,我们可以这样写</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">db</span><span class="class">.users</span><span class="class">.save</span>(<span class="rules">{
                     <span class="rule"><span class="attribute">username</span>:<span class="value"><span class="string">'admin'</span> ,
                     password:<span class="string">'admin'</span>,
                     register_time : new <span class="function">Date()</span>,
              </span></span></span>})
</pre></td></tr></table></figure>

<p>现在我们点击红框框里的执行按钮,运行我们刚刚写的代码<br><img src="/img/mongoInstall/mongodb1_7.jpg" alt="robomongo的使用"></p>
<h3 id="查询">查询</h3>
<p>执行成功后我们发现左边collections下多出一张users表,此时我们执行代码来查询一下users表中都有神马<br>以下命令将查询出users中所有数据：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.find</span>()
</pre></td></tr></table></figure>

<p>我们看到刚才插入的数据确实已经在这张users表中了<br><img src="/img/mongoInstall/mongodb1_8.jpg" alt="robomongo的使用"></p>
<h3 id="更新">更新</h3>
<p>我们尝试把刚刚插入的那个用户的密码改成123456</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.update</span>(
    { <span class="string">"username"</span>: <span class="string">"admin"</span> },
    { <span class="string">"$set"</span>: { <span class="string">"password"</span>: <span class="string">"123456"</span> } }
)
</pre></td></tr></table></figure>

<p>之后查询一下<br><img src="/img/mongoInstall/mongodb1_9.jpg" alt="robomongo的使用"><br>我们发现密码字段已经变成了123456</p>
<h3 id="插入">插入</h3>
<p>我们尝试插入一条新数据</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">db</span><span class="class">.users</span><span class="class">.insert</span>(<span class="rules">{
                     <span class="rule"><span class="attribute">username</span>:<span class="value"><span class="string">'test'</span> ,
                     password:<span class="string">'test'</span>,
                     register_time : new <span class="function">Date()</span>
              </span></span></span>})
</pre></td></tr></table></figure>

<p>第一次执行成功，我们不小心执行了两次！<br>查询一下，也许我们只希望出现一个叫做test的用户，可是现在数据库中有两个了！<br><img src="/img/mongoInstall/mongodb1_11.jpg" alt="robomongo的使用"></p>
<p>我们想保证文档的”username”键都有不一样的值，创建唯一索引可以确保集合的每一个文档的指定值都有唯一值。</p>
<h3 id="唯一索引">唯一索引</h3>
<p>我们先把重复创建的名叫test的用户删除（只保留了一个test用户），再来执行下面代码创建唯一索引：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.ensureIndex</span>({<span class="string">"username"</span>:<span class="number">1</span>},{<span class="string">"unique"</span>:true})
</pre></td></tr></table></figure>

<p>创建成功后，我们再执行上面插入名叫test的用户（此时已经有一个叫test的用户在数据库中）<br><img src="/img/mongoInstall/mongodb1_12.jpg" alt="robomongo的使用"><br>我们发现报错了！test用户插入不进去，因为唯一索引起了作用，用find查询，也并没有改变，我们的唯一索引创建成功~</p>
<h3 id="删除">删除</h3>
<p>我们再尝试将admin这个user删除掉(注意：这里是筛选条件的删除)</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db.users.remove({<span class="string">'username'</span>:<span class="string">'admin'</span>})
</pre></td></tr></table></figure>

<p>之后查询下<br><img src="/img/mongoInstall/mongodb1_13.jpg" alt="robomongo的使用"><br>我们发现现在admin这个用户已经被删除，只剩下了test用户…</p>
<p><em>注意</em>：remove操作较危险,要小心给其传递条件,如果不加条件,像这样:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.remove</span>()
</pre></td></tr></table></figure>

<p>运行该命令后会移除users数据库中所有的数据,需谨慎使用！</p>
<p>目前为止,是基础中的基础,很简单对不对？不过实际应用中会比上述例子要复杂得多。</p>
<h3 id="在Node-js中使用MongoDB">在Node.js中使用MongoDB</h3>
<p>使用mongoose类库，可以让JSON数据直接入库MongoDB。这里并不做过多介绍,有兴趣,或需要用到的朋友可以去了解下。<br>mongoose官网：<a href="http://mongoosejs.com/" target="_blank">http://mongoosejs.com/</a></p>
<h4 id="一些问题">一些问题</h4>
<p>以下记录一点,我遇到的问题,其实并不难,但是如果要去找就很花时间。</p>
<p>有一张表，表结构如下(此为缩略版本的mongoose的表结构)：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> VersionSchema = <span class="keyword">new</span> Schema({
	                            username:{ type:<span class="built_in">String</span>, index: <span class="literal">true</span> } ,
	                            historyVersion:
		                            [
			                            {
			                                version:<span class="built_in">String</span>,
				                            time : { type: <span class="built_in">Date</span>, <span class="keyword">default</span>: <span class="built_in">Date</span>.now },
				                            describe:<span class="built_in">String</span>
			                            }
		                            ]
                            });
<span class="keyword">var</span> Version = mongodb.mongoose.model(<span class="string">"Version"</span>, VersionSchema);
</pre></td></tr></table></figure>

<p>historyVersion是一个数组，数组里面存放的是对象类型。</p>
<ul>
<li>关于覆盖一个表中类型为数组中的某个对象的某个字段 = =<br>我要改historyVersion这个数组的某个对象的某个字段的值。<br>做法如下：<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db.versions.update(
    { <span class="string">"username"</span>: <span class="string">"admin"</span>,<span class="string">'historyVersion._id'</span>:ObjectId(<span class="string">"539db613ec7788dc2414cacf"</span>) },
    { <span class="string">"<span class="variable">$set</span>"</span>: { <span class="string">"historyVersion.$.version"</span>: <span class="string">"2"</span> } }
)
</pre></td></tr></table></figure>

</li>
</ul>
<p>historyVersion中对象中的_id是自动生成的，通过这个来辨别更新哪个对象里的字段</p>
<ul>
<li>关于删除一个表中类型为数组中的某个对象<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db.versions.update(
    {<span class="string">'username'</span><span class="symbol">:<span class="string">'test'</span></span>},
    {<span class="variable">$pull</span><span class="symbol">:</span>{<span class="string">'historyVersion'</span><span class="symbol">:</span>{<span class="string">'_id'</span><span class="symbol">:ObjectId</span>(<span class="string">"539dcd6b29fb842026d1a5f3"</span>)}}}
)
</pre></td></tr></table></figure>













</li>
</ul>
]]></content>
    
    
      <category term="mongodb" scheme="http://snailsky.me/tags/mongodb/"/>
    
      <category term="mongo" scheme="http://snailsky.me/tags/mongo/"/>
    
      <category term="安装" scheme="http://snailsky.me/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="实践笔记" scheme="http://snailsky.me/categories/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 编程实践 - UI层的松耦合 (二)]]></title>
    <link href="http://snailsky.me/2014/06/07/javascript-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-ui%E5%B1%82%E7%9A%84%E6%9D%BE%E8%80%A6%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://snailsky.me/2014/06/07/javascript-编程实践-ui层的松耦合（二）/</id>
    <published>2014-06-07T07:46:17.000Z</published>
    <updated>2014-07-14T08:38:33.000Z</updated>
    <content type="html"><![CDATA[<p><em>这是一篇读书笔记，对书中的描述进行精简，归纳，总结，<br>有时也会自己写一些例子，感想和扩展 O(∩_∩)O~</em></p>
<hr>
<h2 id="5-将HTML从JavaScript中抽离">5.将HTML从JavaScript中抽离</h2>
<p>正如我们需要将JavaScript从HTML中抽离一样，最好也将HTML从JavaScript中抽离。避免HTML的问题被埋在JavaScript代码中，以节省调试时间。</p>
<h3 id="常见问题">常见问题</h3>
<p>在JavaScript中使用HTML的情形往往是给innerHTML属性赋值时，比如：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 不好的写法</span>
var <span class="keyword">div</span> = document.getElementById(<span class="string">"my-div"</span>);
<span class="keyword">div</span>.innerHTML = <span class="string">"&lt;h3&gt;Error&lt;/h3&gt;&lt;p&gt;Invalid e-mail address.&lt;/p&gt;"</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：将HTML嵌入JavaScript代码中是非常不好的实践。<br><strong>缺点</strong>：增加了跟踪文本和结构性问题的复杂度。追踪bug变得困难。<br>如果你希望修改文本或标签，你只希望去一个地方：可以控制你HTML代码的地方。如果你的标签出现在一处便可以很方便地更新它们。<br>相比于修改JavaScript代码，修改标签通常不会引发太多错误。当HTML和JavaScript混淆在一起时，问题将变得复杂。JavaScript字符串需要对引号做适当转义，这样则会导致它和模板语言的原生语法略有差异。</p>
<h3 id="解决方法">解决方法</h3>
<p>因为多数Web应用本质上都是动态的，需要通过JavaScript向页面插入或修改标签。有很多方法可以以低耦合方式完成这项工作。</p>
<h4 id="方式一：从服务器加载">方式一：从服务器加载</h4>
<p>将模板放置于远程服务器，使用XMLHttpRequest对象来获取外部标签。<br>例：点击一个链接，希望弹出一个新对话框，代码可能如下：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">loadDialog</span><span class="params">(name, oncomplete)</span>{</span>
    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
    xhr.open(<span class="string">"get"</span>, <span class="string">"/js/dialog"</span> + name, <span class="literal">true</span>);

    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> && xhr.status == <span class="number">200</span>) {
            <span class="keyword">var</span> div = document.getElementById(<span class="string">"dlg-holder"</span>);
            div.innerHTML = xhr.responseText;
            oncomplete();
        }<span class="keyword">else</span>{
            <span class="comment">// 处理错误</span>
        }
    }；
    xhr.send(<span class="literal">null</span>);
}
</pre></td></tr></table></figure>

<p><strong>评价</strong>：低耦合，对单页应用带来更多便捷。<br><strong>优点</strong>：这里没有将HTML字符串嵌入在JavaScript里，而是向服务器发起请求获取字符串，这样可以让HTML代码以最合适的方式注入到页面中。<br><strong>缺点</strong>：这种方法（从服务器获取模板）很容易造成XSS漏洞，需要服务器对模板文件做适当转义处理，比如&lt;和&gt;以及双引号等，当然前端也应当给出与之匹配的渲染规则，总之这种方法需要一揽子前后端的转码和解码策略来尽可能地封堵XSS漏洞。</p>
<p><strong>JavaScript类库</strong>将这个操作做了封装，使得直接给DOM元素挂在内容变得非常方便。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// YUI</span>
<span class="function"><span class="keyword">function</span> <span class="title">loadDialog</span><span class="params">(name, oncomplete)</span>{</span>
    <span class="transposed_variable">Y.</span>one(<span class="string">"#dlg-holder"</span>).<span class="built_in">load</span>(<span class="string">"/js/dialog/"</span> + name, oncomplete);
}
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// jQuery</span>
<span class="function"><span class="keyword">function</span> <span class="title">loadDialog</span><span class="params">(name, oncomplete)</span>{</span>
    $(<span class="string">"#dlg-holder"</span>).load(<span class="string">"/js/dialog/"</span> + name, oncomplete);
}
</pre></td></tr></table></figure>

<p><strong>适用时机</strong>：当你需要注入大段HTML标签到页面中时，使用远程调用的方式来加载标签是非常有帮助的。出于性能的原因，将大量没用的标签存放于内存或DOM中是很糟糕的做法。对于少量的标签段可以考虑采用客户端模板。</p>
<h4 id="方式二：简单客户端模板">方式二：简单客户端模板</h4>
<p>客户端模板是一些带“插槽”的标签片段，这些“插槽”会被JavaScript程序替换为数据以保证模板的完整可用。<br><em>比如：一段用来添加数据项的模板看起来就像下面这样。</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</pre></td></tr></table></figure>

<p>这段模板中包含%s占位符，这个位置的文本会被程序替换掉（这个格式和C语言中的sprintf（）一模一样）。JavaScript程序会将这些占位符替换为真实数据，然后将结果注入DOM。</p>
<p>那么<em>模板放在哪儿呢？</em><br>通常我们将模板定义在其他标签之间，直接存放于HTML页面里，这样可以被JavaScript读取，用以下两种方法之一可做到。</p>
<p><strong>模板位置一</strong>：在HTML注释中包含模板文本。</p>
<p>注释是和元素及文本一样的DOM节点，因此可以通过JavaScript将其提取出来。<br><em>完整实例如下</em>（书上的例子有些小问题，所以整理试了下，以下程序亲测可用）：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 简单客户端模板（模板位置一） - HTML代码 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span><span class="comment">&lt;!--&lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;--&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">//    简单客户端模板（模板位置一） - JavaScript代码</span>
<span class="comment">//    用参数替换占位符</span>
<span class="function"><span class="keyword">function</span> <span class="title">sprintf</span><span class="params">(text)</span>{</span>
    <span class="keyword">var</span> i=<span class="number">1</span>,args=<span class="built_in">arguments</span>;
    <span class="keyword">return</span> text.replace(<span class="regexp">/%s/g</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> (i &lt; args.length) ? args[i++] : <span class="string">""</span>;
    });
}
<span class="comment">//    将填充模板之后的结果添加到适当位置</span>
<span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">(url, text)</span>{</span>
    <span class="keyword">var</span> mylist = document.getElementById(<span class="string">"mylist"</span>),
        templateText = mylist.firstChild.nodeValue,
        <span class="comment">//templateText:  &lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;</span>
        result = sprintf(templateText,  url,  text);
    mylist.insertAdjacentHTML(<span class="string">"beforeend"</span>, result);
}
<span class="comment">//    用法</span>
addItem(<span class="string">"/item/4"</span>, <span class="string">"Fourth item"</span>);
</pre></td></tr></table></figure>

<p><em>笔记</em>：</p>
<ul>
<li><p>HTML代码中的注释部分一定要和上一级的开始标签挨着（此处就是注释和&lt;ul&gt;挨着），如果是像这样写</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 错误的写法 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span>
    <span class="comment">&lt;!--&lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;--&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var mylist = document<span class="preprocessor">.getElementById</span>(<span class="string">"mylist"</span>),
    templateText = mylist<span class="preprocessor">.firstChild</span><span class="preprocessor">.nodeValue</span><span class="comment">;</span>
</pre></td></tr></table></figure><br>将获取不到<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>insertAdjacentHTML方法：在指定的地方插入html标签语句<br>原型：insertAdajcentHTML(swhere,stext)<br>参数：swhere: 指定插入html标签语句的地方，有四种值可用：</p>
</li>
</ul>
<ol>
<li>beforeBegin: 插入到标签开始前</li>
<li>afterBegin:插入到标签开始标记之后</li>
<li>beforeEnd:插入到标签结束标记前</li>
<li>afterEnd:插入到标签结束标记后</li>
</ol>
<p><strong>模板位置二</strong>：放在一个带有自定义type属性的&lt;script&gt;元素。</p>
<p>浏览器会默认将&lt;script&gt;元素中的内容识别为JavaScript代码，但你可以通过给type赋值为浏览器不识别的类型，来告诉浏览器这不是一段JavaScript脚本。</p>
<p><em>完整实例如下</em>：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 简单客户端模板（模板位置二） - HTML代码 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>//    简单客户端模板（模板位置二） - 模板写在script元素中
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-my-template"</span> <span class="attribute">id</span>=<span class="value">"list-item"</span>&gt;</span><span class="javascript">
    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">//    简单客户端模板（模板位置二） - JavaScript代码</span>
<span class="comment">//    用参数替换占位符</span>
<span class="function"><span class="keyword">function</span> <span class="title">sprintf</span><span class="params">(text)</span>{</span>
    <span class="keyword">var</span> i=<span class="number">1</span>,args=<span class="built_in">arguments</span>;
    <span class="keyword">return</span> text.replace(<span class="regexp">/%s/g</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> (i &lt; args.length) ? args[i++] : <span class="string">""</span>;
    });
}
<span class="comment">//    将填充模板之后的结果添加到适当位置</span>
<span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">(url, text)</span>{</span>
    <span class="keyword">var</span> mylist = document.getElementById(<span class="string">"mylist"</span>),
        script = document.getElementById(<span class="string">"list-item"</span>),
        templateText = script.text,
        result = sprintf(templateText,  url,  text),
        div = document.createElement(<span class="string">"div"</span>);

    div.innerHTML = result.replace(<span class="regexp">/^\s*/</span>, <span class="string">""</span>);
    mylist.appendChild(div.firstChild);
}
<span class="comment">//    用法</span>
addItem(<span class="string">"/item/4"</span>, <span class="string">"Fourth item"</span>);
</pre></td></tr></table></figure>

<p><em>笔记</em>：</p>
<ul>
<li>函数中去掉了模板文本中的前导空格<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>result.<span class="operator"><span class="keyword">replace</span>(/^\s*/, <span class="string">""</span>);</span>
</pre></td></tr></table></figure><br>之所以会出现这个多余的前导空格，是因为模板文本总是在 &lt;script&gt;起始标签的下一行。如果将模板文本原样注入，则会在 &lt;div&gt;里创建一个文本结点，这个文本节点的内容是一个空格，而这个文本节点最终会代替 &lt;li&gt;被添加进列表之中。</li>
</ul>
<h4 id="方式三：复杂客户端模板">方式三：复杂客户端模板</h4>
<p>前两种方式模板格式都非常简单，无太多转义，如果想用一些更健壮的模板，可以考虑诸如<a href="http://handlebarsjs.com/" target="_blank">Handlebars</a>所提供的解决方案。</p>
<p>Handlebars是专为浏览器端JavaScript设计的完整的客户端模板系统。<br>在Handlebars的模板中，占位符使用双花括号来表示。</p>
<p><em>上一节中的模板Handlebars版本完整实例如下</em>：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 复杂客户端模板（Handlebars） - HTML代码 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>//    复杂客户端模板（Handlebars） - 模板写在script元素中
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-handlebars-template"</span> <span class="attribute">id</span>=<span class="value">"list-item"</span>&gt;</span><span class="javascript">
    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">""</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>//    复杂客户端模板（Handlebars） - JavaScript代码
function addItem(url, text){
    var mylist = document<span class="preprocessor">.getElementById</span>(<span class="string">"mylist"</span>),
        script = document<span class="preprocessor">.getElementById</span>(<span class="string">"list-item"</span>),
        templateText = script<span class="preprocessor">.text</span>,
        template = Handlebars<span class="preprocessor">.compile</span>(templateText),
        div = document<span class="preprocessor">.createElement</span>(<span class="string">"div"</span>),
        result<span class="comment">;</span>

        <span class="comment">/* 变量template包含了一个函数，当执行这个函数时则返回一个
        格式化好的字符串，你需要做的仅仅是传入一个包含属性的对象，
        参数会自动做HTML转义。*/</span>
        result = template({
            text:text,
            url:url
        })<span class="comment">;</span>
    div<span class="preprocessor">.innerHTML</span> = result<span class="comment">;</span>
    mylist<span class="preprocessor">.appendChild</span>(div<span class="preprocessor">.firstElementChild</span>)<span class="comment">;</span>
}
//    用法
addItem(<span class="string">"/item/4"</span>, <span class="string">"Fourth item"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p><em>笔记</em>：</p>
<ul>
<li><p>要使用Handlebars首先要将Handlebars类库引入页面。这个类库会创建一个名为Handlebars的全局变量，用来将模板文本编译为一个函数。<br>我是用的 bower 来安装 Handlebars 的：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>bower <span class="keyword">install</span> handlebars -g
</pre></td></tr></table></figure><br>(注：Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。)<br>安装后记得引用进页面来：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/javascripts/handlebars.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>在Handlebars模板中，占位符都记为一个名称，以便可以在JavaScript中设计其映射。Handlebars 建议将模板嵌入 HTML 页面中，并使用 type 属性为 “text/x-handlebars-template”的&lt;script&gt;标签来表示（如上例所示）</p>
</li>
<li><p>变量template包含了一个函数，当执行这个函数时则返回一个格式化好的字符串，你需要做的仅仅是传入一个包含属性的对象。参数会自动做HTML转义，转义操作也是格式化的一部分。转义是为了增强模板的安全性，并确保简单的文本值不会破坏你的标签结构。比如，字符”&amp;”会自动转义为 “&amp;amp”;</p>
</li>
<li><p>关于上面例子的写法，最初我尝试用之前的写法：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>mylist<span class="preprocessor">.appendChild</span>(div<span class="preprocessor">.firstChild</span>)<span class="comment">;</span>
</pre></td></tr></table></figure><br>可是无效，我又打印出div看，div 的 firstChild 确实是li，可是打印 div.firstChild 出来是“#text”它的值貌似是个回车。我发现打印div下有个 firstElementChild 和 firstChild 里面的东西一样的所以就用 firstElementChild 试了，还真可以，不过还是不懂为什么firstChild不行了，大家如果知道原因，求指点。</p>
</li>
</ul>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="书" scheme="http://snailsky.me/tags/%E4%B9%A6/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 编程实践 - UI层的松耦合 (一)]]></title>
    <link href="http://snailsky.me/2014/05/31/javascript-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-UI%E5%B1%82%E7%9A%84%E6%9D%BE%E8%80%A6%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://snailsky.me/2014/05/31/javascript-编程实践-UI层的松耦合（一）/</id>
    <published>2014-05-31T03:33:37.000Z</published>
    <updated>2014-07-21T15:09:34.000Z</updated>
    <content type="html"><![CDATA[<p><em>这是一篇读书笔记，对书中的描述进行精简，归纳，总结，<br>有时也会自己写一些例子，感想和扩展 O(∩_∩)O~</em></p>
<hr>
<h1 id="UI层的松耦合">UI层的松耦合</h1>
<p>WEB开发中 UI由三个彼此隔离又相互作用的层定义（HTML,CSS,JavaScript）。</p>
<p>在实际场景中，css和JavaScript是同等重要的，两者更像是兄弟关系并非依赖关系（javascript依赖css）。<br>一个页面很可能只有HTML和CSS而没有JavaScript,<br>或………………只有HTML和JavaScript而没有CSS。</p>
<p>在所有Web UI中，JavaScript的正确运行不应依赖CSS—在缺少CSS情况下也要能够正确运行，尽管两者之间可能有互动。</p>
<h2 id="1-_什么是松耦合">1. 什么是松耦合</h2>
<h3 id="1-1_什么是耦合：">1.1 什么是耦合：</h3>
<p>如果两个组件耦合太紧，则说明一个组件和另一个组件直接相关，<br>如果修改一个组件的逻辑，那么另外一个组件的逻辑也需修改。</p>
<p>耦合的例子：有一个贯穿整个站点的css类叫做error，被嵌入到HTML中。如果有一天你要改error这个名字为warning，不仅要修改CSS还要修改用到这个类名的HTML，HTML和CSS紧耦合在一起。</p>
<h3 id="1-2_什么时候才能称作松耦合：">1.2 什么时候才能称作松耦合：</h3>
<p>当你能够做到修改一个组件而不需要更改其他组件时，你就做到了松耦合。</p>
<p>松耦合是易于调试的，这对于代码的可维护性来说至关重要。修改某部分代码是不会破坏其他人的代码，那便是极好的 0.0’</p>
<p>在一起工作的组件无法达到“无耦合”，我们的目标是确保对一个组件的修改不会经常性地影响其他部分。</p>
<h2 id="2-_将JavaScript从CSS中抽离">2. 将JavaScript从CSS中抽离</h2>
<p>IE8和更早版本的浏览器中有一个特性让人爱少恨多，即CSS表达式（CSS expression）。<br>CSS表达式允许你将JavaScript直接插入到CSS中，可以在CSS代码中直接执行运算或其他操作。</p>
<p><em>设置元素宽度以匹配浏览器宽度</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/* 不好的写法 */</span>
<span class="class">.box</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="function">expression(document.body.offsetWidth + <span class="string">"px"</span>)</span></span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>CSS表达式包裹在一个特殊的expression()函数中，可以给它传入任意JavaScript代码。<br>浏览器会以高频率重复计算CSS表达式，严重影响了性能。且难以维护。<br>IE9不再支持CSS表达式，老版本IE依然可以运行CSS表达式。<br>有人会用CSS表达式来让低版本浏览器里也达到和高级浏览器一致的表现，但尽量避免使用，以避免浪费不必要的时间精力。</p>
<p><strong>总结</strong>：避免使用CSS表达式</p>
<h2 id="3-_将CSS从JavaScript中抽离">3. 将CSS从JavaScript中抽离</h2>
<p>CSS和JavaScript互相协作的很不错，所以我们经常将样式数据和JavaScript混写在一起。</p>
<h3 id="JavaScript改CSS方式：">JavaScript改CSS方式：</h3>
<h4 id="方式一（不好）：style属性">方式一（不好）：style属性</h4>
<p>直接修改DOM元素的style属性。</p>
<p>style属性是一个对象，包含了可以读取和修改的CSS属性。<br><em>如：修改元素文本颜色</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 不好的写法 */</span>
element<span class="preprocessor">.style</span><span class="preprocessor">.color</span> = <span class="string">"red"</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：这种写法经常看到，但是这种写法是有问题的。<br><strong>缺点</strong>：当出现样式问题，通常首先去查找CSS，而非JavaScript，浪费时间。<br><strong>例外</strong>：有一种使用style属性的情形是可以接受的:<br>当你需要给页面中的元素作定位，使其相对于另外一个元素或整个页面重新定位。这种计算在CSS中无法完成，<br>此时可以使用style.top、style.left、style.bottom、style.right 来对元素作正确定位。<br>在CSS中定义这个元素的默认属性，而在JavaScript中修改这些默认值。</p>
<h4 id="方式二（不好）：cssText属性">方式二（不好）：cssText属性</h4>
<p>给cssText属性赋值整个CSS字符串</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 不好的写法 */</span>
element<span class="preprocessor">.style</span><span class="preprocessor">.cssText</span> = <span class="string">"color: red; left: 10px; top: 100px; visibility: hidden"</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：这种写法是一次性设置多个CSS属性的一种快捷方法，同样有问题。<br><strong>缺点</strong>：比如设置单个属性时：将样式信息写入JavaScript带来了可维护性问题。</p>
<h4 id="方式三（最佳）：操作className">方式三（最佳）：操作className</h4>
<p>操作CSS的className</p>
<p><em>例：在页面中显示一个对话框，css中的样式定义像下面这样</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="class">.reveal</span><span class="rules">{
    <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">10</span>px</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100</span>px</span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> visible</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure><br><em>在JavaScript中像这样将样式添加至元素。</em><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - 原生方法 */</span>
element<span class="preprocessor">.className</span> += <span class="string">" reveal"</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - HTML5 */</span>
element<span class="preprocessor">.classList</span><span class="preprocessor">.add</span>(<span class="string">"reveal"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - YUI */</span>
<span class="built_in">Y</span><span class="preprocessor">.one</span>(element)<span class="preprocessor">.addClass</span>(<span class="string">"reveal"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - jQuery */</span>
$(element).addClass(<span class="string">"reveal"</span>);
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - Dojo */</span>
dojo<span class="preprocessor">.addClass</span>(element, <span class="string">"reveal"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：JavaScript可以随意添加删除元素的className，而className定义的样式则在CSS代码中。<br>CSS样式随时可以修改，而不必更新JavaScript。<br><strong>优点</strong>：JavaScript未直接操作样式，保持了和CSS的松耦合。</p>
<h2 id="4-将JavaScript从HTML中抽离">4.将JavaScript从HTML中抽离</h2>
<p>很多人学习JavaScript之初所做的第一件事是，将脚本嵌入HTML中来运行。</p>
<h3 id="绑定事件方式">绑定事件方式</h3>
<h4 id="方式一_（不好）：使用on属性">方式一 （不好）：使用on属性</h4>
<p>使用on属性（ 比如onclick ）绑定一个事件处理程序</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不好的写法 --&gt;</span>
<span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"doSomething()"</span> <span class="attribute">id</span>=<span class="value">"action-btn"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：此写法2000年时非常流行，尽管这种代码多数场景下是正常工作的，但却是两个UI层（HTML和JavaScript）的深耦合，这种写法有一些问题<br><strong>缺点</strong>：</p>
<ol>
<li>点击事件发生时，doSomething()函数必须存在，否则会报JavaScript错误，页面或弹出错误信息或点击事件不会有任何响应。</li>
<li>如果修改了doSomething()的函数名或如果此时点击按钮调用了其他函数，需要同时修改JavaScript和HTML代码。给维护带来了困难，这是典型的紧耦合的代码。</li>
</ol>
<h4 id="方式二（最佳）：_通过&lt;script&gt;标签来引用">方式二（最佳）： 通过&lt;script&gt;标签来引用</h4>
<p>绝大多数（并非所有的）JavaScript代码包含在外部文件中，并在页面中通过&lt;script&gt;标签来引用。<br>对于支持2级DOM模型的浏览器来说，用下代码可完成上面例子中的功能：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span>{</span>
    <span class="comment">//代码</span>
}
<span class="keyword">var</span> btn = document.getElementById(<span class="string">"action-btn"</span>);
btn.addEventListener(<span class="string">"click"</span>, doSomething, <span class="literal">false</span>);
</pre></td></tr></table></figure><br><strong>关于addEventListener()函数</strong>：<br>IE8及其更早的版本不支持addEventListener()函数，因此需要一个标准的函数将这些差异性做封装。<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">/*
 * 这个函数可以做到在各种浏览器中给一个元素添加事件处理程序
 * 甚至可以降级到支持给0级DOM模型对象的on属性赋值处理程序
 * （只有在非常古老的浏览器），比如Netscape4中，才会执行这一步，
 * 因此这段代码可以在所有情形下都正常工作）
 */</span>
<span class="keyword">function</span> addListener(target, <span class="class"><span class="keyword">type</span>, <span class="title">handler</span>){</span>
    <span class="keyword">if</span>(target.addEventListener){
        target.addEventListener(<span class="class"><span class="keyword">type</span>, <span class="title">handler</span>, <span class="title">false</span>);</span>
    }<span class="keyword">else</span> <span class="keyword">if</span>(target.attachEvent){
    		target.attachEvent(<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>, <span class="title">handler</span>);</span>
    }<span class="keyword">else</span>{
        target[<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>] =</span> handler;
    }
}
</pre></td></tr></table></figure><br>我们常常像下面这样来使用这个方法<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span>{</span>
    <span class="comment">//代码</span>
}
<span class="keyword">var</span> btn = document.getElementById(<span class="string">"action-btn"</span>);
addListener(btn, <span class="string">"click"</span>, doSomething);
</pre></td></tr></table></figure><br>如果你用了 <strong>JavaScript 类库</strong>，可以使用类库提供的方法来给元素挂载事件处理程序<br>这里给出一些流行类库中的实例代码。<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>// YUI
<span class="built_in">Y</span><span class="preprocessor">.one</span>(<span class="string">"#action-btn"</span>)<span class="preprocessor">.on</span>(<span class="string">"click"</span>, doSomething)<span class="comment">;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// jQuery</span>
$(<span class="string">"#action-btn"</span>).on(<span class="string">"click"</span>, doSomething);
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// Dojo</span>
<span class="keyword">var</span> btn = dojo.byId(<span class="string">"action-btn"</span>);
dojo.connect(btn, <span class="string">"click"</span>, doSomething);
</pre></td></tr></table></figure>

<p><strong>评价</strong>：优势在于，函数doSomething()的定义和事件处理程序绑定都是在一个文件中完成的。如果函数名称需要修改，则只需修改一个文件；<br>如果点击事件发生时想额外做些动作，也只需在一处做修改。<br><strong>优点</strong>：不需同时修改多个文件，可维护性提高，实现了松耦合。</p>
<h4 id="方式三_（不好）：HTML中内联的脚本代码">方式三 （不好）：HTML中内联的脚本代码</h4>
<p>在HTML中使用&lt;script&gt;标签，标签内包含内联的脚本代码。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不好的写法 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    doSomething();
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：最好将所有JavaScript代码都放入外置文件中，以确保在HTML代码中不会有内联的JavaScript代码，利于调试。<br><strong>缺点</strong>：不利于确信（而非猜测）从何下手调试bug</p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="书" scheme="http://snailsky.me/tags/%E4%B9%A6/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello My Blog]]></title>
    <link href="http://snailsky.me/2014/05/18/hello-my-blog/"/>
    <id>http://snailsky.me/2014/05/18/hello-my-blog/</id>
    <published>2014-05-18T14:50:49.000Z</published>
    <updated>2014-07-12T02:26:57.000Z</updated>
    <content type="html"><![CDATA[<p>这是<strong>我的blog </strong>，我正在创建第一篇日志。<br>今后的博客的测试什么的也将在这篇博客里尝试~</p>
<p>我要在这开始我的博客之旅咯…</p>
<p>最重要的代码神马的这样写…</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(<span class="string">"hello world"</span>);
</pre></td></tr></table></figure>
]]></content>
    
    
      <category term="日记" scheme="http://snailsky.me/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="http://snailsky.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="生活随笔" scheme="http://snailsky.me/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
