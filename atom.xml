<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Running_snail's Blog]]></title>
  <subtitle><![CDATA[Some notes about Web Front-End and others]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://snailsky.me/"/>
  <updated>2014-09-27T16:39:05.217Z</updated>
  <id>http://snailsky.me/</id>
  
  <author>
    <name><![CDATA[running_snail]]></name>
    <email><![CDATA[505324327@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript事件处理程序与事件代理]]></title>
    <link href="http://snailsky.me/2014/09/17/JavaScript%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"/>
    <id>http://snailsky.me/2014/09/17/JavaScript事件处理程序与事件代理/</id>
    <published>2014-09-17T07:18:17.000Z</published>
    <updated>2014-09-20T11:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>总结DOM中和IE中事件对象的属性和方法；<br>封装一个通用的事件处理类；<br>理解事件代理</p>
<p>在此备忘，方便查询使用 O(∩_∩)O</p>
<hr>
<h2 id="事件对象">事件对象</h2>
<h3 id="DOM中的事件对象（常用的）">DOM中的事件对象（常用的）</h3>
<p><strong>type属性 用于获取事件类型</strong></p>
<blockquote>
<p>event.type</p>
</blockquote>
<p><strong>target属性 用于获取事件目标</strong></p>
<blockquote>
<p>event.target</p>
</blockquote>
<p>你也可以获取事件目标的节点名称</p>
<blockquote>
<p>event.target.nodeName</p>
</blockquote>
<p><strong>stopPropagation()方法 用于阻止事件冒泡</strong></p>
<blockquote>
<p>event.stopPropagation()</p>
</blockquote>
<p><strong>preventDefault()方法  阻止事件的默认行为</strong></p>
<blockquote>
<p>event.preventDefault()</p>
</blockquote>
<p>tip:默认行为是什么？<br>例如 a标签<br>&lt;a href=”#”&gt;超链接&lt;/a&gt;<br>的默认行为就是跳转。</p>
<p>阻止a的默认行为就是阻止a跳转。</p>
<h3 id="IE中的事件对象（常用的）">IE中的事件对象（常用的）</h3>
<p><strong>type属性 用于获取事件类型</strong></p>
<blockquote>
<p>event.type</p>
</blockquote>
<p><strong>srcElement属性 用于获取事件目标</strong></p>
<blockquote>
<p>event.srcElement</p>
</blockquote>
<p><strong>cancelBubble属性 用于阻止事件冒泡</strong><br>设置为true表示阻止冒泡</p>
<blockquote>
<p>event.cancelBubble=true</p>
</blockquote>
<p>设置为false表示不阻止冒泡</p>
<blockquote>
<p>event.cancelBubble=false</p>
</blockquote>
<p><strong>returnValue属性  阻止事件的默认行为</strong><br>默认为true<br>设置为false表示阻止事件的默认行为</p>
<blockquote>
<p>event.returnValue=false</p>
</blockquote>
<p><strong>关于event</strong>：<br>IE8之前的浏览器event要这样获取：</p>
<blockquote>
<p>window.event</p>
</blockquote>
<p>因此我们的event这样获取便可兼容所有浏览器：</p>
<blockquote>
<p>event = event || window.event</p>
</blockquote>
<hr>
<h2 id="跨浏览器事件处理程序">跨浏览器事件处理程序</h2>
<h3 id="通用事件处理文件">通用事件处理文件</h3>
<p>此封装了一个事件处理程序函数，此函数应用了能力检测来满足不同浏览器。<br>将此函数放到一个js文件里，需要绑定事件时引用此文件，可处理所有的事件绑定。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="comment">//    跨浏览器事件处理工具</span>

<span class="keyword">var</span> eventUtil = {
    <span class="comment">//    添加事件</span>
    addHandler:<span class="function"><span class="keyword">function</span><span class="params">(element,type,handler)</span>{</span>
        <span class="keyword">if</span>(element.addEventListener){     <span class="comment">// DOM2级事件处理</span>
            element.addEventListener(type,handler,<span class="literal">false</span>);
        }<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent){    <span class="comment">// IE事件处理</span>
            element.attachEvent(<span class="string">"on"</span>+type,handler);
        }<span class="keyword">else</span>{    <span class="comment">//DOM0级事件处理</span>
            element[<span class="string">"on"</span>+type]=handler;
        }
    },
    <span class="comment">//    删除事件</span>
    removeHandler:<span class="function"><span class="keyword">function</span><span class="params">(element,type,handler)</span>{</span>
        <span class="keyword">if</span>(element.removeEventListener){    <span class="comment">// DOM2级事件处理</span>
             element.removeEventListener(type,handler,<span class="literal">false</span>);
        }<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent){    <span class="comment">// IE事件处理</span>
            element.detachEvent(<span class="string">"on"</span>+type,handler);
        }<span class="keyword">else</span>{    <span class="comment">//DOM0级事件处理</span>
            element[<span class="string">"on"</span>+type]=<span class="literal">null</span>;
        }
    },
    <span class="comment">//    获取事件对象</span>
    getEvent:<span class="function"><span class="keyword">function</span><span class="params">(event)</span>{</span>
        <span class="keyword">return</span> event?event:window.event;
    },
    <span class="comment">//    获取事件类型</span>
    getType:<span class="function"><span class="keyword">function</span><span class="params">(event)</span>{</span>
        <span class="keyword">return</span> event.type;
    },
    <span class="comment">//    获取事件目标</span>
    getElement:<span class="function"><span class="keyword">function</span><span class="params">(event)</span>{</span>
        <span class="keyword">return</span> event.target || event.srcElement;
    },
    <span class="comment">//    阻止默认行为</span>
    preventDefault:<span class="function"><span class="keyword">function</span><span class="params">(event)</span>{</span>
        <span class="keyword">if</span>(event.preventDefault){
            event.preventDefault();
        }<span class="keyword">else</span>{
            event.returnValue=<span class="literal">false</span>;
        }
    },
    <span class="comment">//    阻止冒泡</span>
    stopPropagation:<span class="function"><span class="keyword">function</span><span class="params">(event)</span>{</span>
        <span class="keyword">if</span>(event.stopPropagation){
            event.stopPropagation();
        }<span class="keyword">else</span>{
            event.cancelBubble=<span class="literal">true</span>;
        }
    }
}
</pre></td></tr></table></figure>

<h3 id="用法">用法</h3>
<p>引用包含上述代码的文件，我们现在可以使用它来给我们的程序添加事件了~<br>例：我们来给一个按钮绑定一个弹出“hello world”的事件</p>
<p>HTML：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"button"</span> <span class="keyword">value</span>=<span class="string">"按钮"</span> id=<span class="string">"button"</span>&gt;
</pre></td></tr></table></figure>

<p>JS:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> btn=document.getElementById(<span class="string">"button"</span>);
<span class="function"><span class="keyword">function</span> <span class="title">showMes</span><span class="params">()</span>{</span>
    alert(<span class="string">"hello world"</span>);
}
<span class="comment">//  添加事件</span>
eventUtil.addHandler(btn,<span class="string">"click"</span>,showMes);
<span class="comment">//  删除事件</span>
eventUtil.removeHandler(btn,<span class="string">"click"</span>,showMes);
</pre></td></tr></table></figure>

<p>测试一下，chrome和IE都没有问题，你可以试一下更低的版本，都OK。</p>
<hr>
<h2 id="事件代理">事件代理</h2>
<h3 id="什么是事件代理？">什么是事件代理？</h3>
<p>当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。</p>
<p>例：假设有一个 UL 的父节点，包含了很多个 Li 的子节点</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"parent-list"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"post-1"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"post-2"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"post-3"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"post-4"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"post-5"</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"post-6"</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure>

<p>当我们的鼠标移到Li上的时候，需要获取此Li的相关信息并飘出悬浮窗以显示详细信息，或者当某个Li被点击的时候需要触发相应的处理事件。<br>我们通常的写法，是为每个Li都添加一些类似onMouseOver或者onClick之类的事件监听。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">function</span> addListeners4Li(liNode){
    liNode.onclick = <span class="keyword">function</span> clickHandler(){<span class="keyword">...</span>};
    liNode.onmouseover = <span class="keyword">function</span> mouseOverHandler(){<span class="keyword">...</span>}
}

window.onload = <span class="keyword">function</span>(){
    var ulNode = document.getElementById(<span class="string">"parent-list"</span>);
    var liNodes = ulNode.getElementByTagName(<span class="string">"Li"</span>);
    <span class="keyword">for</span>(var i=<span class="number">0</span>, l = liNodes.length; i &lt; l; i++){
        addListeners4Li(liNodes[i]);
    }
}
</pre></td></tr></table></figure>

<p>如果这个UL中的Li子元素会频繁地添加或者删除，我们就需要在每次添加Li的时候都调用这个addListeners4Li方法来为每个Li节点添加事件处理函数。这就添加的复杂度和出错的可能性。</p>
<p>更简单的方法是使用事件代理机制，当事件被抛到更上层的父节点的时候，我们通过检查事件的目标对象（target）来判断并获取事件源Li。下面的代码可以完成我们想要的效果：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>// 获取父节点，并为它添加一个click事件
document<span class="preprocessor">.getElementById</span>(<span class="string">"parent-list"</span>)<span class="preprocessor">.addEventListener</span>(<span class="string">"click"</span>,function(e) {
  // 检查事件源e<span class="preprocessor">.targe</span>是否为Li
  if(e<span class="preprocessor">.target</span> && e<span class="preprocessor">.target</span><span class="preprocessor">.nodeName</span><span class="preprocessor">.toUpperCase</span> == <span class="string">"LI"</span>) {
    // 真正的处理过程在这里
    console<span class="preprocessor">.log</span>(<span class="string">"List item "</span>,e<span class="preprocessor">.target</span><span class="preprocessor">.id</span><span class="preprocessor">.replace</span>(<span class="string">"post-"</span>),<span class="string">" was clicked!"</span>)<span class="comment">;</span>
  }
})<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>为父节点添加一个click事件，当子节点被点击的时候，click事件会从子节点开始向上冒泡。父节点捕获到事件之后，通过判断e.target.nodeName来判断是否为我们需要处理的节点。并且通过e.target拿到了被点击的Li节点。从而可以获取到相应的信息，并作处理。</p>
<h3 id="在JavaScript编程中使用代理">在JavaScript编程中使用代理</h3>
<p>上面介绍的是对DOM事件处理时，利用浏览器冒泡机制为DOM元素添加事件代理。其实在纯JS编程中，我们也可以使用这样的编程模式，来创建代理对象来操作目标对象。这里引用司徒正美相关文章中的一个例子：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">var</span> delegate = <span class="function"><span class="keyword">function</span><span class="params">(client, clientMethod)</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> clientMethod.apply(client, <span class="built_in">arguments</span>);
    }
}
<span class="keyword">var</span> ClassA = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> _color = <span class="string">"red"</span>;
    <span class="keyword">return</span> {
        getColor: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(<span class="string">"Color: "</span> + _color);
        },
        setColor: <span class="function"><span class="keyword">function</span><span class="params">(color)</span> {</span>
            _color = color;
        }
    };
};

<span class="keyword">var</span> a = <span class="keyword">new</span> ClassA();
a.getColor();
a.setColor(<span class="string">"green"</span>);
a.getColor();
console.log(<span class="string">"执行代理！"</span>);
<span class="keyword">var</span> d = delegate(a, a.setColor);
d(<span class="string">"blue"</span>);
console.log(<span class="string">"执行完毕！"</span>);
a.getColor();
</pre></td></tr></table></figure>

<p>上面的例子中，通过调用delegate()函数创建的代理函数d来操作对a的修改。这种方式尽管是使用了apply（call也可以）来实现了调用对象的转移，但是从编程模式上实现了对某些对象的隐藏，可以保护这些对象不被随便访问和修改。</p>
<p>用js函数的apply方法来制定执行作用域，可以解决很多问题。</p>
<h3 id="jQuery中delegate函数">jQuery中delegate函数</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>$(<span class="string">"#link-list"</span>).delegate(<span class="string">"a"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
  <span class="comment">// "$(this)" is the node that was clicked</span>
  console.log(<span class="string">"you clicked a link!"</span>,$(<span class="keyword">this</span>));
});
</pre></td></tr></table></figure>

<p>jQuery的delegate的方法需要三个参数，一个选择器，一个时间名称，和事件处理函数。</p>
<p><strong>优点</strong></p>
<p>1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。</p>
<p>2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。</p>
<p>3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</p>
<hr>
<p>参考文献：<br><a href="http://book.douban.com/subject/10546125/" target="_blank">[1] JavaScript高级程序设计（第3版）- 事件</a><br><a href="http://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html" target="_blank">[2] JavaScript事件代理和委托（Delegation）</a></p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="总结" scheme="http://snailsky.me/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="跨浏览器" scheme="http://snailsky.me/tags/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【JS】JavaScript 中 this 是如何工作的？]]></title>
    <link href="http://snailsky.me/2014/08/31/javascript-%E4%B8%AD-this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/"/>
    <id>http://snailsky.me/2014/08/31/javascript-中-this-是如何工作的？/</id>
    <published>2014-08-30T16:13:42.000Z</published>
    <updated>2014-09-16T07:37:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="this关键字的含义">this关键字的含义</h2>
<p>简单说，this就是指当前函数的运行环境。由于JavaScript支持运行环境的动态切换，所以this的指向是动态的。<br>所谓“运行环境”其实就是对象。可以理解成，this指函数运行时所在的那个对象。</p>
<p>例：有一个函数f，它同时充当a对象和b对象的方法。JavaScript允许函数f的运行环境动态切换，即一会属于a对象，一会属于b对象，这就要靠this关键字来办到。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span>{</span> console.log(<span class="keyword">this</span>.x); };

<span class="keyword">var</span> a = {x:<span class="string">'a'</span>};
a.m = f;

<span class="keyword">var</span> b = {x:<span class="string">'b'</span>};
b.m = f;

a.m() <span class="comment">// a</span>
b.m() <span class="comment">// b</span>
</pre></td></tr></table></figure>

<p>当f属于a对象时，this指向a；当f属于b对象时，this指向b，因此打印出了不同的值。由于this的指向可变，所以达到了运行环境动态切换的目的。</p>
<h2 id="this在不同情况下，指向各不相同">this在不同情况下，指向各不相同</h2>
<h3 id="全局环境/函数调用">全局环境/函数调用</h3>
<p>在全局环境使用this，它指的就是顶层对象window。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>) <span class="regexp">//</span> <span class="literal">true</span>

<span class="reserved">function</span> f() {
    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="regexp">//</span> <span class="literal">true</span>
}
f();
</pre></td></tr></table></figure>

<p>不管是不是在函数内部，只要是在全局环境下运行，this就是指全局对象window。</p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数中的this，指的是实例对象。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> O = <span class="function"><span class="keyword">function</span><span class="params">(p)</span> {</span>
    <span class="keyword">this</span>.p = p;
};

O.prototype.m = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.p;
};

<span class="comment">// test</span>

<span class="keyword">var</span> a = <span class="keyword">new</span> O(<span class="string">"test case 1"</span>);
console.log ( a.p ); <span class="comment">// test case 1</span>
console.log ( a.m() ); <span class="comment">// test case 1</span>

<span class="keyword">var</span> b = <span class="keyword">new</span> O(<span class="string">"test case 2"</span>);
console.log ( b.p ); <span class="comment">// test case 2</span>
console.log ( b.m() ); <span class="comment">// test case 2</span>
</pre></td></tr></table></figure>

<p>上面代码定义了一个构造函数O。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性；然后m方法可以返回这个p属性。</p>
<h3 id="方法调用">方法调用</h3>
<p>当a对象的方法被赋予b对象，该方法就变成了普通函数，其中的this就从指向a对象变成了指向b对象。这就是this取决于运行时所在的对象的含义，所以要特别小心。如果将某个对象的方法赋值给另一个对象，会改变this的指向。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();
o1.m = <span class="number">1</span>;
o1.f = <span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span> console.log(<span class="keyword">this</span>.m);};

o1.f() <span class="comment">// 1</span>

<span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();
o2.m = <span class="number">2</span>;
o2.f = o1.f

o2.f() <span class="comment">// 2</span>
</pre></td></tr></table></figure>

<p>f是o1的方法，但是如果在o2上面调用这个方法，f方法中的this就会指向o2。这就说明JavaScript函数的运行环境完全是动态绑定的，可以在运行时切换。</p>
<p>如果不想改变this的指向，可以将o2.f改写成下面这样。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="transposed_variable">o2.</span>f = <span class="function"><span class="keyword">function</span> <span class="params">()</span>{ <span class="title">o1</span>.<span class="title">f</span><span class="params">()</span> };</span>

<span class="transposed_variable">o2.</span>f() <span class="comment">// 1</span>
</pre></td></tr></table></figure>

<p>上面代码表示，由于f方法这时是在o1下面运行，所以this就指向o1。</p>
<p>有时，某个方法位于多层对象的内部，这时如果为了简化书写，把该方法赋值给一个变量，往往会得到意想不到的结果。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">/*会得到一个意外的答案*/</span>

<span class="keyword">var</span> a = {
        b : {
            m : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                console.log(<span class="keyword">this</span>.p);
            },
            p : <span class="string">'Hello'</span>
        }
};

<span class="keyword">var</span> hello = a.b.m;
hello(); <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<p>上面代码表示，m属于多层对象内部的一个方法。为求简写，将其赋值给hello变量，结果调用时，<strong>this指向了全局对象</strong>。<br>为了避免这个问题，可以<strong>只将m所在的对象赋值给hello</strong>，这样调用时，this的指向就不会变。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> hello = a.b;
hello.m() <span class="comment">// Hello</span>
</pre></td></tr></table></figure>

<h3 id="Node-js">Node.js</h3>
<p>在Node.js中，this的指向又分成两种情况。全局环境中，this指向<a href="http://nodejs.org/api/globals.html" target="_blank">全局对象global</a>；模块环境中，this指向module.exports。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 全局环境</span>
<span class="keyword">this</span> === global <span class="comment">// true</span>

<span class="comment">// 模块环境</span>
<span class="keyword">this</span> === <span class="keyword">module</span>.exports <span class="comment">// true</span>
</pre></td></tr></table></figure>

<p>在浏览器环境下，最高作用域是global作用域，这意味着变量会定义在全局变量下。<br>而在Node下，最高最高作用域不是global作用域，定义的变量属于Node模块。<br>在Node.js中怎样使用全局变量：<a href="http://stackoverflow.com/questions/10987444/how-to-use-global-variable-in-node-js" target="_blank">http://stackoverflow.com/questions/10987444/how-to-use-global-variable-in-node-js</a></p>
<h2 id="使用this你需要注意">使用this你需要注意</h2>
<h3 id="一个常见的误解">一个常见的误解</h3>
<h4 id="避免多层this-例一">避免多层this-例一</h4>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="reserved">var</span> Foo = {};
Foo.method = <span class="reserved">function</span>() {
    <span class="built_in">console</span>.log(<span class="string">"Foo.method中this是否指向Foo ："</span> ,<span class="keyword">this</span> === Foo);
    <span class="built_in">console</span>.log(<span class="string">"Foo.method中this："</span> ,<span class="keyword">this</span>);
    <span class="reserved">function</span> test() {
        <span class="built_in">console</span>.log(<span class="string">"Foo.method中test函数的this是否指向Foo ："</span> ,<span class="keyword">this</span> === Foo);
        <span class="built_in">console</span>.log(<span class="string">"Foo.method中test函数的this是否指向window ："</span>,<span class="keyword">this</span> === <span class="built_in">window</span>);
        <span class="built_in">console</span>.log(<span class="string">"Foo.method中test函数的this："</span>,<span class="keyword">this</span>);<span class="regexp">//</span> <span class="keyword">this</span> 将会被设置为全局对象（浏览器环境中也就是 <span class="built_in">window</span> 对象）
    }
    test();
}

Foo.method();
</pre></td></tr></table></figure>

<p>一个常见的误解是 test 中的 this 将会指向 Foo 对象，实际上不是这样子的。<br>大家也可以自己去试下，我直接贴我试的结果—<br><img src="/img/js/testthis1.jpg" alt="this的误解"><br>可以看到 Foo.method 这个函数中的 this 指向的是 Foo 这个对象，<br>而 Foo.method 中 test 函数的 this 指向的并不是Foo这个对象，而是 window 这个对象。</p>
<p><strong>解决方法</strong>：为了在 test 中获取对 Foo 对象的引用，我们需要在 method 函数内部创建一个局部变量指向 Foo 对象。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> Foo = {};
Foo.method = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">"Foo.method中this是否指向Foo ："</span> ,<span class="keyword">this</span> === Foo);
    <span class="keyword">var</span> that = <span class="keyword">this</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> {</span>
        console.log(<span class="string">"Foo.method中test函数的that是否指向Foo ："</span> ,that === Foo);
    }
    test();
}

Foo.method();
</pre></td></tr></table></figure>

<p>that 只是我们随意起的名字，不过这个名字被广泛的用来指向外部的 this 对象。<br><img src="/img/js/testthis2.jpg" alt="this的误解"></p>
<h4 id="避免多层this-例二">避免多层this-例二</h4>
<p>与例一类似的：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> o = {
    f1: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(<span class="keyword">this</span>);
        <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(<span class="keyword">this</span>);
        }();
    }
}

o.f1()
<span class="comment">// Object</span>
<span class="comment">// Window</span>
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis2-1.jpg" alt="this的误解"><br>两层this，结果运行后，第一层指向该对象，第二层指向全局对象。<br><strong>解决方法</strong>(同例一)：在第二层改用一个指向外层this的变量, 定义变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> o = {
    f1: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(<span class="keyword">this</span>);
        <span class="keyword">var</span> that = <span class="keyword">this</span>;
        <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(that);
        }();
    }
}

o.f1()
<span class="comment">// Object</span>
<span class="comment">// Object</span>
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis2-2.jpg" alt="this的误解"></p>
<h4 id="避免数组处理方法中的this">避免数组处理方法中的this</h4>
<p>数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> o = {
    v: <span class="string">'hello'</span>,
    p: [ <span class="string">'a1'</span>, <span class="string">'a2'</span> ],
    f: <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.p.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> {</span>
            console.log(<span class="keyword">this</span>.v+<span class="string">' '</span>+item);
        });
    }
}

o.f()
<span class="comment">// undefined a1</span>
<span class="comment">// undefined a2</span>
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis2-3.jpg" alt="this的误解"><br>上面代码中，foreach方法的参数函数中的this，其实是指向window对象，因此取不到o.v的值。</p>
<p><strong>解决方案一</strong>:使用中间变量 - 这与避免多层this解决方法一样。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> o = {
    v: <span class="string">'hello'</span>,
    p: [ <span class="string">'a1'</span>, <span class="string">'a2'</span> ],
    f: <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> that = <span class="keyword">this</span>;
        <span class="keyword">this</span>.p.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> {</span>
            console.log(that.v+<span class="string">' '</span>+item);
        });
    }
}

o.f()
<span class="comment">// hello a1</span>
<span class="comment">// hello a2</span>
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis2-4.jpg" alt="this的误解"></p>
<p><strong>解决方案二</strong>:将this当作foreach方法的第二个参数，固定它的运行环境。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> o = {
    v: <span class="string">'hello'</span>,
    p: [ <span class="string">'a1'</span>, <span class="string">'a2'</span> ],
    f: <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.p.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> {</span>
            console.log(<span class="keyword">this</span>.v+<span class="string">' '</span>+item);
        }, <span class="keyword">this</span>);
    }
}

o.f()
<span class="comment">// hello a1</span>
<span class="comment">// hello a2</span>
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis2-5.jpg" alt="this的误解"></p>
<h3 id="方法的赋值表达式">方法的赋值表达式</h3>
<p>另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> Foo = {};
Foo.method = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">"this是否指向Foo ："</span> ,<span class="keyword">this</span> === Foo);
    console.log(<span class="string">"this指向："</span> ,<span class="keyword">this</span>);
}

Foo.method();
<span class="keyword">var</span> test = Foo.method;
test();
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis3.jpg" alt="this的误解"></p>
<p>上例中，test 就像一个普通的函数被调用；因此，函数内的 this 将不再被指向到 Foo 对象。</p>
<p>虽然 this 的晚绑定特性似乎并不友好，但是这确实基于原型继承赖以生存的土壤。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span> {</span>}
Foo.prototype.method = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">"this指向："</span> ,<span class="keyword">this</span>);
};

<span class="function"><span class="keyword">function</span> <span class="title">Bar</span><span class="params">()</span> {</span>}
Bar.prototype = Foo.prototype;

<span class="keyword">new</span> Bar().method();
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis4.jpg" alt="this的误解"></p>
<p>当 method 被调用时，this 将会指向 Bar 的实例对象。</p>
<h3 id="避免回调函数中的this">避免回调函数中的this</h3>
<p>回调函数中的this往往会改变指向，最好避免使用。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();

o.f = <span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    console.log(<span class="keyword">this</span> === o);
}

o.f() <span class="comment">// true</span>
</pre></td></tr></table></figure>

<p><img src="/img/js/testthis2-6.jpg" alt="this的误解"><br>上面代码表示，如果调用o对象的f方法，其中的this就是指向o对象。</p>
<p>但是，如果将f方法指定给某个按钮的click事件，this的指向就变了。<br>$(“#button”).on(“click”, o.f);</p>
<p>点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的DOM对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<p>为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。</p>
<h2 id="固定this的方法">固定this的方法</h2>
<p>this的动态切换，固然为JavaScript创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，反正出现意想不到的情况。</p>
<p>JavaScript提供了call、apply、bind这三个方法，来固定this的指向。</p>
<h3 id="call方法">call方法</h3>
<p>函数的call方法，可以改变指定该函数内部this的指向，然后再调用该函数。它的使用格式如下。</p>
<blockquote>
<p>func.call(thisValue, arg1, arg2, …)</p>
</blockquote>
<p><strong>thisValue</strong>:第一个参数是this所要指向的那个对象。(如果this所要指向的那个对象，设定为null或undefined，则等同于指定全局对象。)<br><strong>arg1,arg2, …</strong>:函数调用时所需的参数</p>
<h4 id="例">例</h4>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> n = <span class="number">123</span>;

<span class="keyword">var</span> o = { n : <span class="number">456</span> };

<span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span> {</span>
    console.log(<span class="keyword">this</span>.n);
}

a.call() <span class="comment">// 123</span>
a.call(<span class="literal">null</span>) <span class="comment">// 123</span>
a.call(<span class="literal">undefined</span>) <span class="comment">// 123</span>
a.call(window) <span class="comment">// 123</span>
a.call(o) <span class="comment">// 456</span>
</pre></td></tr></table></figure>

<p>上面代码中，a函数中的this关键字，如果指向全局对象，返回结果为123。<br>如果使用call方法，将this关键字指向o对象，返回结果为456。</p>
<h3 id="apply方法">apply方法</h3>
<p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。它的使用格式如下。</p>
<blockquote>
<p>func.apply(thisValue, [arg1, arg2, …])</p>
</blockquote>
<p><strong>thisValue</strong>:第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。<br><strong>[arg1, arg2, …]</strong>:第二个参数是一个数组，该数组的所有成员依次作为参数，传入原函数。<br>原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</p>
<h4 id="例-1">例</h4>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x,y)</span>{</span> console.log(x+y); }

f.call(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 2</span>
f.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">1</span>]) <span class="comment">// 2</span>
</pre></td></tr></table></figure>

<p>上面的f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用。</p>
<h4 id="应用一：找出数组最大元素">应用一：找出数组最大元素</h4>
<p>JavaScript不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];

<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, a)
<span class="comment">// 15</span>
</pre></td></tr></table></figure>

<p>上例等同于这样写</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>);
<span class="comment">// 15</span>
</pre></td></tr></table></figure>

<p>关于Math.max:</p>
<blockquote>
<p>定义和用法:<br>max() 方法可返回两个指定的数中带有较大的值的那个数。</p>
<p>语法:<br>Math.max(x…)</p>
<p>参数:<br>0 或多个值。在 ECMASCript v3 之前，该方法只有两个参数。</p>
<p>返回值:<br>参数中最大的值。如果没有参数，则返回 -Infinity。如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。</p>
</blockquote>
<h4 id="应用二：将数组的空元素变为undefined">应用二：将数组的空元素变为undefined</h4>
<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Array.apply(null, [<span class="string">"a"</span>,,<span class="string">"b"</span>])
// [ '<span class="literal">a</span>', undefined, 'b' ]
</pre></td></tr></table></figure>

<p>关于Array构造函数：</p>
<blockquote>
<p>创建 Array 对象的语法：<br>new Array();<br>new Array(size);<br>new Array(element0, element1, …, elementn);</p>
<p>参数:<br>参数 size 是期望的数组元素个数。返回的数组，length 字段将被设为 size 的值。<br>参数 element …, elementn 是参数列表。当使用这些参数来调用构造函数 Array() 时，新创建的数组的元素就会被初始化为这些值。它的 length 字段也会被设置为参数的个数。</p>
<p>返回值:<br>返回新创建并被初始化了的数组。<br>如果调用构造函数 Array() 时没有使用参数，那么返回的数组为空，length 字段为 0。<br>当调用构造函数时只传递给它一个数字参数，该构造函数将返回具有指定个数、元素为 undefined 的数组。<br>当其他参数调用 Array() 时，该构造函数将用参数指定的值初始化数组。<br>当把构造函数作为函数调用，不使用 new 运算符时，它的行为与使用 new 运算符调用它时的行为完全一样。</p>
</blockquote>
<p>空元素与undefined的差别在于，数组的foreach方法会跳过空元素，但是不会跳过undefined。<br>因此，遍历内部元素的时候，会得到不同的结果。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> a = [<span class="string">"a"</span>,,<span class="string">"b"</span>];

<span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">(i)</span> {</span>
    console.log(i);
}

a.<span class="keyword">forEach</span>(<span class="keyword">print</span>)
<span class="comment">// a</span>
<span class="comment">// b</span>

<span class="keyword">Array</span>.apply(<span class="keyword">null</span>,a).<span class="keyword">forEach</span>(<span class="keyword">print</span>)
<span class="comment">// a</span>
<span class="comment">// undefined</span>
<span class="comment">// b</span>
</pre></td></tr></table></figure>

<h4 id="应用三：转换类似数组的对象">应用三：转换类似数组的对象</h4>
<p>利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Array<span class="preprocessor">.prototype</span><span class="preprocessor">.slice</span><span class="preprocessor">.apply</span>({<span class="number">0</span>:<span class="number">1</span>,length:<span class="number">1</span>})
// [<span class="number">1</span>]

Array<span class="preprocessor">.prototype</span><span class="preprocessor">.slice</span><span class="preprocessor">.apply</span>({<span class="number">0</span>:<span class="number">1</span>})
// []

Array<span class="preprocessor">.prototype</span><span class="preprocessor">.slice</span><span class="preprocessor">.apply</span>({<span class="number">0</span>:<span class="number">1</span>,length:<span class="number">2</span>})
// [<span class="number">1</span>, undefined]

Array<span class="preprocessor">.prototype</span><span class="preprocessor">.slice</span><span class="preprocessor">.apply</span>({length:<span class="number">1</span>})
// [undefined]
</pre></td></tr></table></figure>

<p>关于slice方法：</p>
<blockquote>
<p>定义和用法:<br>slice() 方法可从已有的数组中返回选定的元素。</p>
<p>语法<br>arrayObject.slice(start,end)</p>
<p>参数<br>start:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。<br>end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
<p>返回值<br>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
<p>说明<br>请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</p>
</blockquote>
<p><strong>slice例一</strong>：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="reserved">var</span> arr = <span class="keyword">new</span> Array(<span class="number">3</span>)
arr[<span class="number">0</span>] = <span class="string">"George"</span>
arr[<span class="number">1</span>] = <span class="string">"John"</span>
arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>

<span class="built_in">console</span>.log(arr)
<span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>))
<span class="built_in">console</span>.log(arr)
<span class="regexp">//</span>  [<span class="string">"George"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]
<span class="regexp">//</span>  [<span class="string">"John"</span>, <span class="string">"Thomas"</span>]
<span class="regexp">//</span>  [<span class="string">"George"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]
</pre></td></tr></table></figure>

<p><strong>slice例二</strong>：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="reserved">var</span> arr = <span class="keyword">new</span> Array(<span class="number">6</span>)
arr[<span class="number">0</span>] = <span class="string">"George"</span>
arr[<span class="number">1</span>] = <span class="string">"John"</span>
arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>
arr[<span class="number">3</span>] = <span class="string">"James"</span>
arr[<span class="number">4</span>] = <span class="string">"Adrew"</span>
arr[<span class="number">5</span>] = <span class="string">"Martin"</span>

<span class="built_in">console</span>.log(arr)
<span class="built_in">console</span>.log(arr.slice(<span class="number">2</span>,<span class="number">4</span>))
<span class="built_in">console</span>.log(arr)
<span class="regexp">//</span>  [<span class="string">"George"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]
<span class="regexp">//</span>  [<span class="string">"Thomas"</span>, <span class="string">"James"</span>]
<span class="regexp">//</span>  [<span class="string">"George"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]
</pre></td></tr></table></figure>

<h4 id="应用四：绑定回调函数的对象">应用四：绑定回调函数的对象</h4>
<p>之前的按钮点击事件的例子，可以改写成</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();

o.f = <span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    console.log(<span class="keyword">this</span> === o);
}

<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    o.f.apply(o);
    <span class="comment">// 或者 o.f.call(o);</span>
};

$(<span class="string">"#button"</span>).on(<span class="string">"click"</span>, f);
</pre></td></tr></table></figure>

<p>点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。<br>更简洁的写法是采用下面介绍的bind方法。</p>
<h3 id="bind方法">bind方法</h3>
<p>bind方法就是单纯地将函数体内的this绑定到某个对象，然后返回一个新函数。它的使用格式如下。</p>
<blockquote>
<p>func.bind(thisValue, arg1, arg2,…)</p>
</blockquote>
<p>它比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。</p>
<p>请看下面的例子。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();
o1.p = <span class="number">123</span>;
o1.m = <span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    console.log(<span class="keyword">this</span>.p);
};

o1.m() <span class="comment">// 123</span>

<span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();
o2.p = <span class="number">456</span>;
o2.m = o1.m;

o2.m() <span class="comment">// 456</span>

o2.m = o1.m.bind(o1);
o2.m() <span class="comment">// 123</span>
</pre></td></tr></table></figure>

<p>上面代码使用bind方法将o1.m方法绑定到o1以后，在o2对象上调用o1.m的时候，o1.m函数体内部的this.p就不再到o2对象去寻找p属性的值了。</p>
<p>如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向全局对象（在浏览器中为window）。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x,y)</span> {</span> <span class="keyword">return</span> x+y; }

<span class="keyword">var</span> plus5 = add.bind(<span class="literal">null</span>, <span class="number">5</span>);

plus5(<span class="number">10</span>) <span class="comment">// 15</span>
</pre></td></tr></table></figure>

<h4 id="使用bind时需注意">使用bind时需注意</h4>
<h5 id="每一次返回一个新函数">每一次返回一个新函数</h5>
<p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。<br>比如，监听事件的时候，不能写成下面这样。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>element.addEventListener(<span class="string">'click'</span>, o.<span class="keyword">m</span>.<span class="keyword">bind</span>(o));
</pre></td></tr></table></figure>

<p>上面代码表示，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>element.removeEventListener(<span class="string">'click'</span>, o.<span class="keyword">m</span>.<span class="keyword">bind</span>(o));
</pre></td></tr></table></figure>

<p>正确的方法是写成下面这样：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>var listener = o.m.bind(o);
element.addEventListener(<span class="string">'click'</span>, listener);
//  <span class="keyword">...</span>
element.removeEventListener(<span class="string">'click'</span>, listener);
</pre></td></tr></table></figure>

<h5 id="bind方法的自定义代码">bind方法的自定义代码</h5>
<p>对于那些不支持bind方法的老式浏览器，可以自行定义bind方法。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">if</span>(!(<span class="string">'bind'</span> <span class="keyword">in</span> <span class="built_in">Function</span>.prototype)){
    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">var</span> fn = <span class="keyword">this</span>;
        <span class="keyword">var</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>];
        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">return</span> fn.apply(context, args);
        }
    }
}
</pre></td></tr></table></figure>

<h5 id="jQuery的proxy方法">jQuery的proxy方法</h5>
<p>除了用bind方法绑定函数运行时所在的对象，还可以使用jQuery的$.proxy方法，它与bind方法的作用基本相同。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$(<span class="string">"#button"</span>)<span class="preprocessor">.on</span>(<span class="string">"click"</span>, $<span class="preprocessor">.proxy</span>(o<span class="preprocessor">.f</span>, o))<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>上面代码表示，$.proxy方法将o.f方法绑定到o对象。</p>
<h5 id="结合call方法使用">结合call方法使用</h5>
<p>利用bind方法，可以改写一些JavaScript原生方法的使用形式，以数组的slice方法为例。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="attr_selector">[1,2,3]</span><span class="class">.slice</span>(0,1)
<span class="comment">// [1]</span>

<span class="comment">// 等同于</span>

Array<span class="class">.prototype</span><span class="class">.slice</span><span class="class">.call</span>(<span class="attr_selector">[1,2,3]</span>, 0, 1)
<span class="comment">// [1]</span>
</pre></td></tr></table></figure>

<p>上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。</p>
<p>call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> slice = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">call</span>.<span class="title">bind</span><span class="params">(<span class="keyword">Array</span>.prototype.slice)</span>;</span>

slice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span>
</pre></td></tr></table></figure>

<p>可以看到，利用bind方法，将[1, 2, 3].slice(0, 1)变成了slice([1, 2, 3], 0, 1)的形式。<br>这种形式的改变还可以用于其他数组方法。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>var <span class="keyword">push</span> = Function<span class="preprocessor">.prototype</span><span class="preprocessor">.call</span><span class="preprocessor">.bind</span>(Array<span class="preprocessor">.prototype</span><span class="preprocessor">.push</span>)<span class="comment">;</span>
var <span class="keyword">pop</span> = Function<span class="preprocessor">.prototype</span><span class="preprocessor">.call</span><span class="preprocessor">.bind</span>(Array<span class="preprocessor">.prototype</span><span class="preprocessor">.pop</span>)<span class="comment">;</span>

var a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>]<span class="comment">;</span>
<span class="keyword">push</span>(a, <span class="number">4</span>)
a // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]

<span class="keyword">pop</span>(a)
a // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
</pre></td></tr></table></figure>

<p>如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span>{</span>
    console.log(<span class="keyword">this</span>.v);
}

<span class="keyword">var</span> o = { v: <span class="number">123</span> };

<span class="keyword">var</span> bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind);

bind(f,o)() <span class="comment">// 123</span>
</pre></td></tr></table></figure>

<p>上面代码表示，将Function.prototype.call方法绑定Function.prototype.bind以后，bind方法的使用形式从f.bind(o)，变成了bind(f, o)。</p>
<hr>
<p>参考文献：<br><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc5" target="_blank">[1] 面向对象编程概述 - JavaScript 标准参考教程（alpha）</a><br><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.this" target="_blank">[2] this 的工作原理 - JavaScript 秘密花园</a><br><a href="http://nodejs.org/api/globals.html" target="_blank">[3] Global Objects - Node.js v0.10.31 Manual &amp; Documentation</a><br><a href="http://stackoverflow.com/questions/10987444/how-to-use-global-variable-in-node-js" target="_blank">[4] How to use global variable in node.js? - stackoverflow</a></p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="stackoverflow" scheme="http://snailsky.me/tags/stackoverflow/"/>
    
      <category term="原理" scheme="http://snailsky.me/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[block-level boxes、containing block、block formatting context]]></title>
    <link href="http://snailsky.me/2014/08/24/block-level-boxes%E3%80%81containing-block%E3%80%81block-formatting-context/"/>
    <id>http://snailsky.me/2014/08/24/block-level-boxes、containing-block、block-formatting-context/</id>
    <published>2014-08-24T11:05:15.000Z</published>
    <updated>2014-08-25T17:46:47.000Z</updated>
    <content type="html"><![CDATA[<p>在知乎看到这样一个问题“CSS 中 block-level boxes、containing block、block formatting context 三者之间的区别和联系是怎样的？”<br>我傻傻分不清楚 = =，这必须记录一下这些概念加深印象，备个忘，同时也让自己掰扯掰扯这些概念。<br>（以下标准翻译部分是博主自己尝试翻译的 &gt;_&lt; ，如有错误或不到位的请指正）</p>
<hr>
<h2 id="标准中的描述">标准中的描述</h2>
<h3 id="Block-level_elements_and_block_boxes">Block-level elements and block boxes</h3>
<p><a href="http://www.w3.org/TR/CSS21/visuren.html#block-boxes" target="_blank">9.2.1 Block-level elements and block boxes</a></p>
<blockquote>
<p>Block-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the ‘display’ property make an element block-level: ‘block’, ‘list-item’, and ‘table’.</p>
<p>Block-level boxes are boxes that participate in a block formatting context. Each block-level element generates a principal block-level box that contains descendant boxes and generated content and is also the box involved in any positioning scheme. Some block-level elements may generate additional boxes in addition to the principal box: ‘list-item’ elements. These additional boxes are placed with respect to the principal box.</p>
<p>Except for table boxes, which are described in a later chapter, and replaced elements, a block-level box is also a block container box. A block container box either contains only block-level boxes or establishes an inline formatting context and thus contains only inline-level boxes. Not all block container boxes are block-level boxes: non-replaced inline blocks and non-replaced table cells are block containers but not block-level boxes. Block-level boxes that are also block containers are called block boxes.</p>
<p>The three terms “block-level box,” “block container box,” and “block box” are sometimes abbreviated as “block” where unambiguous.</p>
</blockquote>
<p>译：</p>
<p><strong>块级元素（block-level elements）</strong>是源文档中那些以块的形式显示的一些元素（比如：段落（paragraphs））。以下”display”属性值，可以使一个元素 变成块级 ： “block” , “list-item” 和 “table”</p>
<p><strong>块级盒子（block-level boxes）</strong> 会参与到 <strong>块级格式化上下文(block formatting context)</strong>（一种布局方式） 。每个<strong>块级元素</strong>会生成一个<strong>首要块级盒子（principal block-level box）</strong> ，这个<strong>首要块级盒子</strong>包含后代盒子们，以及生成内容，并且这个<strong>块级元素</strong>也被包含到任何一种定位机制中。一些<strong>块级元素</strong>除了会生成<strong>首要块级盒子</strong>之外，还会生成额外盒子们，比如：”list-item” elment。这些额外的盒子参照<strong>首要块级盒子</strong>放置。</p>
<p>除了<strong>表格盒子（table boxes）</strong>（将在之后的章节中描述它）和<strong><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element" target="_blank">可替换元素（replaced elements）</a></strong>，一个<strong>块级盒子</strong>也是一个<strong>块容器盒子（block container box）</strong>。一个<strong>块容器盒子</strong>要么只包含<strong>块级盒子</strong>，要么创建一个只包含<strong>行级盒子（inline-level boxes）</strong>的<strong>行内格式化上下文（inline formatting context）</strong>。不是所有<strong>块容器盒子</strong>都是<strong>块级盒子</strong>，比如：<strong>不可替换行内块（non-replaced inline blocks）</strong>和<strong>不可替换表格单元格</strong>都是<strong>块容器盒子</strong>但不是<strong>块级盒子</strong>。是<strong>块级盒子</strong>又是<strong>块容器盒子</strong>的被叫做<strong>块盒子（block boxes）</strong>。</p>
<p>这三个术语 “<strong>块级盒子（block-level boxes）</strong>“,”<strong>块容器盒子（block container box）</strong>“和”<strong>块盒子（block boxes）</strong>“在表述清晰的条件下有时被简称为”块（block）”。</p>
<hr>
<h3 id="Block_formatting_contexts">Block formatting contexts</h3>
<p><a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting" target="_blank">9.4.1 Block formatting contexts</a></p>
<blockquote>
<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>
<p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p>
<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>
<p>For information about page breaks in paged media, please consult the section on allowed page breaks.</p>
</blockquote>
<p>译:</p>
<p>不是<strong>块盒子（block boxes）</strong>的：<strong>浮动（floats）</strong>，<strong>绝对定位元素（absolutely positioned elements）</strong>，<strong>块容器（block containers）</strong>（如：<strong>行内块（inline-blocks）</strong>，<strong>表格单元格（table-cells）</strong>和<strong>表格标题（table-captions）</strong>）；以及有”overflow”属性，且”overflow”属性值不为”visible”的（除了当值传递到窗口 这句没懂…）都会为他们的内容创建一个新的<strong>块级格式化上下文（block formatting contexts）</strong>。</p>
<p>在一个<strong>块级格式化上下文（block formatting contexts）</strong>中，盒子们自所在的 containing block 顶部起一个接一个垂直排列，水平方向上撑满整个宽度 (除非内部的盒子自己内部建立了新的 BFC)。在两个兄弟盒子之间的垂直间距被定义为”margin”属性。<strong>块级格式化上下文</strong>中毗邻的<strong>块级盒子（block-level boxes）</strong>之间的垂直方向边距不会发生折叠（collapse）。</p>
<p>在一个<strong>块级格式化上下文</strong>中，每个盒子左外边框紧挨着其包含块的左边框（从右向左排列时，右外边框紧挨着其包含块的右边框）。即使是浮动（floats）的情况下也成立（即使一个（父元素）盒子的线框会由于（子元素）浮动收缩），除非这个盒子创建了一个新的<strong>块级格式化上下文</strong>（在这种情况下这个盒子自己会由于浮动会变窄）。</p>
<p>想了解关于<strong>分页媒体（paged media）</strong>中的<strong>分页符（page breaks）</strong>，请查阅这个章节：<a href="http://www.w3.org/TR/CSS21/page.html#allowed-page-breaks" target="_blank">allowed page breaks</a></p>
<hr>
<h2 id="总结/需要注意的">总结/需要注意的</h2>
<h3 id="Block_formatting_contexts-1">Block formatting contexts</h3>
<h4 id="What_triggers_block_formatting_contexts">What triggers block formatting contexts</h4>
<ul>
<li>float 除了none以外的值</li>
<li>overflow 除了visible 以外的值（hidden，auto，scroll ）</li>
<li>display (table-cell，table-caption，inline-block)</li>
<li>position（absolute，fixed）</li>
<li>fieldset元素</li>
</ul>
<h4 id="How_block_formatting_contexts_flow">How block formatting contexts flow</h4>
<p>block formatting contexts 属于普通流（normal flow）</p>
<h4 id="What_block_formatting_contexts_do">What block formatting contexts do</h4>
<ol>
<li><p>创建了 BFC 的元素，不和它的子元素发生外边距折叠。</p>
<p>外边距折叠的规则：仅当两个块级元素相邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。因此，阻止外边距折叠只需产生新的 BFC 。</p>
<p>DEMO:<br><iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/0zad5mtv/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe><br>三个 div 各包含一个 p 元素，三个 div 及其包含的 p 元素都有顶部和底部的外边距，但只有第三个 div 的边距没有与它的子元素 p 的外边距折叠。这是因为第三个 div 创建了新的 BFC ，由此可见：创建了 BFC 的元素，不和它的子元素发生外边距折叠。</p>
</li>
<li><p>BFC 可以包含浮动的元素,闭合浮动。</p>
<p>这也正是使用 overflow: hidden 与 overflow: auto 方法闭合浮动的原理，使用 overflow: hidden 或 overflow: auto 触发浮动元素的父元素的 BFC 特性，从而可以包含浮动元素，闭合浮动。<br>W3C 的原文是“’Auto’ heights for block formatting context roots”，也就是 BFC 会根据子元素的情况自动适应高度，即使其子元素中包括浮动元素。</p>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/2vyexx1q/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>更详细的清除浮动方法可见：<a href="http://snailsky.me/2014/08/20/%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9F/" target="_blank">浮动和它的工作原理？清除浮动的技巧？</a></p>
</li>
<li><p>BFC 可以阻止元素被浮动元素覆盖</p>
<p>浮动元素的块级兄弟元素会无视浮动元素的位置，尽量占满一整行，这样就会被浮动元素覆盖，为该兄弟元素触发 BFC 后可以阻止这种情况的发生。<br>DEMO:<br>块级元素会被它的兄弟浮动元素覆盖</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/8o4ysvor/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>触发了 BFC 的元素不会被它的兄弟浮动元素覆盖</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/xsovngvk/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>子元素宽度均小于父元素，但父元素宽度不足以容纳一行中所有子元素时，非浮动子元素会下沉</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/tewfLt3w/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

</li>
</ol>
<hr>
<h3 id="block-level_boxes">block-level boxes</h3>
<h4 id="relationship_with_block_formatting_contexts">relationship with block formatting contexts</h4>
<p>一个 block-level element (‘display’ 属性值为 ‘block’, ‘list-item’ 或是 ‘table’) 会生成一个 block-level box，<br>这样的盒子会参与到 block-formatting context (一种布局的方式) 中。</p>
<hr>
<h3 id="containing_block">containing block</h3>
<p>一般来说，盒子本身就为其子孙建立了 containing block，用来计算内部盒子的位置、大小，而对内部的盒子，具体采用哪个 containing block 来计算，需要分情况来讨论：</p>
<ol>
<li>根元素所在的 containing block 被称为 initial containing block，在我们常用的浏览器环境下，指的是原点与 canvas 重合，大小和 viewport 相同的矩形；</li>
<li>对于 position 为 static 或 relative 的元素，其 containing block 为祖先元素中最近的 block container box 的 content box (除 margin, border, padding 外的区域)；</li>
<li>对于 position:fixed 的元素，其 containing block 由 viewport 建立；</li>
<li>对于 position:absolute 的元素，则是先找到其祖先元素中最近的 position 属性非 static 的元素，然后判断：<ol>
<li>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</li>
<li>否则则由这个祖先元素的 padding box 构成。<br>如果都找不到，则为 initial containing block。</li>
</ol>
</li>
</ol>
<hr>
<p>参考文献：<br><a href="http://www.w3.org/TR/CSS21/visuren.html#block-boxes" target="_blank">[1] 9.2.1 Block-level elements and block boxes</a><br><a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting" target="_blank">[2] 9.4.1 Block formatting contexts</a><br><a href="http://w3help.org/zh-cn/kb/008/" target="_blank">[3] KB008: 包含块( Containing block )</a><br><a href="http://www.yuiblog.com/blog/2010/05/19/css-101-block-formatting-contexts" target="_blank">[4] CSS 101: Block Formatting Contexts</a><br><a href="http://kayosite.com/block-formatting-contexts-in-detail.html" target="_blank">[5] 详说 Block Formatting Contexts (块级格式化上下文)</a><br><a href="http://stackoverflow.com/questions/6196725/how-does-the-css-block-formatting-context-work" target="_blank">[6] How does the CSS Block Formatting Context work?</a><br><a href="http://www.zhihu.com/question/20086234" target="_blank">[7] CSS 中 block-level boxes、containing block、block formatting context 三者之间的区别和联系是怎样的？</a></p>
]]></content>
    
    
      <category term="CSS" scheme="http://snailsky.me/tags/CSS/"/>
    
      <category term="总结" scheme="http://snailsky.me/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="CSS" scheme="http://snailsky.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS布局总结与实践]]></title>
    <link href="http://snailsky.me/2014/08/21/css%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://snailsky.me/2014/08/21/css布局总结与实践/</id>
    <published>2014-08-21T10:08:23.000Z</published>
    <updated>2014-09-14T03:15:04.000Z</updated>
    <content type="html"><![CDATA[<p>重在实践，把常用的布局及其实践总结在这备忘，方便以后查询和使用。<br>包含了 “如何设置块级元素水平居中” 、 “如何实现左固定宽度或百分比，右边自适应” 等常见问题。<br>和 “外边距折叠” 这类重要的概念。及各种常见的属性和布局。</p>
<hr>
<h2 id="如何设置块级元素水平居中？">如何设置块级元素水平居中？</h2>
<h3 id="方法一(差)：设置width_+_margin">方法一(差)：设置width + margin</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="id">#main</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">600</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/rf810w0s/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h3 id="方法二(可)：设置max-width_+_margin">方法二(可)：设置max-width + margin</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="id">#main</span> <span class="rules">{
  <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">600</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/zqm5hwt1/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2 id="盒子模型">盒子模型</h2>
<h3 id="盒子模型的结构">盒子模型的结构</h3>
<p>为了给文档树中的各个元素排版定位（布局），浏览器会根据渲染模型1为每个元素生成四个嵌套的矩形框， 分别称作 content box、padding box、border box 和 margin box，它们是不可分割的，并可能会重合， 这就是 CSS 规范中描述的“框模型”（box model）。它是以 CSS 的角度去看一个元素被渲染后的抽象形态。 是一个元素自身的构成部分，不同于布局：多个元素在页面上的定位。</p>
<p><img src="/img/CSS/hemoxing2d.png" alt="盒模型"></p>
<p>盒子3D模型：<br><img src="/img/CSS/hemoxing3d.png" alt="盒模型"><br>对于盒子模型如想理解详细，请看这里： <a href="http://w3help.org/zh-cn/kb/006/" target="_blank">CSS 框模型( Box module )</a></p>
<h3 id="外边距折叠(_Collapsing_margins_)">外边距折叠( Collapsing margins )</h3>
<p>Collapsing margins，即外边距折叠，指的是毗邻的两个或多个外边距 (margin) 会合并成一个外边距。</p>
<p>其中所说的 margin 毗邻，可以归结为以下两点：</p>
<ul>
<li>这两个或多个外边距没有被非空内容、padding、border 或 clear 分隔开。</li>
<li>这些 margin 都处于普通流中。（既 in-flow，非浮动元素，非定位元素）</li>
</ul>
<p>其规则为: <strong>两个或多个</strong> <strong>毗邻</strong> 的普通流中的块元素 <strong>垂直</strong> 方向上的 margin 会折叠<br>了解详情，请看：<a href="http://w3help.org/zh-cn/kb/006/" target="_blank">CSS 框模型( Box module )</a></p>
<p>试一试其中的例子：<br>DEMO-1(毗邻)：<br>HTML</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"lightpink"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"lightgreen"</span>&gt;
       &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"lightyellow"</span>&gt;
           &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"lightblue"</span>&gt;D BLOCK&lt;/<span class="keyword">div</span>&gt;
       &lt;/<span class="keyword">div</span>&gt;
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</pre></td></tr></table></figure>

<p>CSS</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="class">.lightpink</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value">lightpink</span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1</span>px solid red</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100</span>px</span></span>;
<span class="rule">}</span></span>
<span class="class">.lightgreen</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">50</span>px <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">background-color</span>:<span class="value">lightgreen</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">50</span>px</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">50</span>px</span></span>;
<span class="rule">}</span></span>
<span class="class">.lightyellow</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value">lightyellow</span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">20</span>px <span class="number">0</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.lightblue</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value">lightblue</span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">100</span>px <span class="number">0</span></span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/wuzpm0uw/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>在没有被非空内容、padding、border 或 clear 分隔开（毗邻）的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻； 只有在一个元素的 height 是 “auto” 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。</p>
<p>此例中的 lightgreen块（margin:50px 0;） 与 它的第一个且最后一个子元素 lightyellow块（margin:100px,0;） 毗邻 且 lightyellow块（margin:50px 0;） 与 它的第一个且最后一个元素 lightblue块（margin:100px 0;）毗邻，<br>他们的 margin-top 发生合并，取最大值，此时lightgreen块的 margin-top 为 100px。<br>而因为 lightgreen块（margin:50px 0;）有 height 值（height:50px;）因此它的 margin-bottom 与其最后一个子元素 lightyellow块（margin:20px 0;）的 margin-bottom 并不相邻，因此 margin-bottom 不发生合并,此时lightgreen块的 margin-bottom 为 50px。</p>
<p>所以我们看到了 lightpink块 被 lightgreen块 撑开 而margin-top和margin-bottom看起来不同，就是这个道理啦…</p>
<hr>
<h4 id="折叠后_margin_的计算">折叠后 margin 的计算</h4>
<p>DEMO-2(参与折叠的 margin 都是正值):</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"height:50px; margin-bottom:50px; width:50px; background-color: red;"</span>&gt;</span>A<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"height:50px; margin-top:100px; width:50px; background-color: green;"</span>&gt;</span>B<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/zeLm7tj3/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>由上结果观察到：A 与 B 间距 100px;<br><strong>结论</strong>：在 margin 都是正数的情况下，取其中 margin 较大的值为最终 margin 值。</p>
<hr>
<p>DEMO-3(参与折叠的 margin 都是负值):</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"height:100px; margin-bottom:-75px; width:100px; background-color: red;"</span>&gt;</span>A<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"height:100px; margin-top:-50px; margin-left:50px; width:100px; background-color: green;"</span>&gt;</span>B<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/kqfohd9d/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>由上结果观察到：A 与 B 重叠部分高度 75px;<br><strong>结论</strong>：当 margin 都是负值的时候，取的是其中绝对值较大的，然后，从 0 位置，负向位移。</p>
<hr>
<p>DEMO-4(参与折叠的 margin 中有正值，有负值):</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"height:50px; margin-bottom:-50px; width:50px; background-color: red;"</span>&gt;</span>A<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"height:50px; margin-top:100px; width:50px; background-color: green;"</span>&gt;</span>B<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/sppwxkg7/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>由上结果观察到：A 与 B 间距 50（px)=100+（-50）;<br><strong>结论</strong>：有正有负，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。</p>
<hr>
<p>DEMO-5(相邻的 margin 要一起参与计算，不得分步计算):<br>要注意，相邻的元素不一定非要是兄弟节点，父子节点也可以，即使不是兄弟父子节点也可以相邻。</p>
<p>而且，在计算时，相邻的 margin 要一起参与计算，不得分步计算。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>&lt;<span class="operator">div</span> style=<span class="string">"background-color:green; width:50px;"</span>&gt;
    <span class="keyword">before</span> A
&lt;/<span class="operator">div</span>&gt;
&lt;<span class="operator">div</span> style=<span class="string">"margin:50px 0; background-color:green; width:50px;"</span>&gt;
    &lt;<span class="operator">div</span> style=<span class="string">"margin:-60px 0;"</span>&gt;
           &lt;<span class="operator">div</span> style=<span class="string">"margin:150px 0;"</span>&gt;A&lt;/<span class="operator">div</span>&gt;
    &lt;/<span class="operator">div</span>&gt;
&lt;/<span class="operator">div</span>&gt;
&lt;<span class="operator">div</span> style=<span class="string">"margin:-100px 0; background-color:green; width:50px;"</span>&gt;
    &lt;<span class="operator">div</span> style=<span class="string">"margin:-120px 0;"</span>&gt;
           &lt;<span class="operator">div</span> style=<span class="string">"margin:200px 0;"</span>&gt;B&lt;/<span class="operator">div</span>&gt;
    &lt;/<span class="operator">div</span>&gt;
&lt;/<span class="operator">div</span>&gt;
&lt;<span class="operator">div</span> style=<span class="string">"background-color:green; width:50px;"</span>&gt;
    <span class="keyword">after</span> B
&lt;/<span class="operator">div</span>&gt;
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/o1gqj3jn/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>为了方便观察结果我添加了一个 “before A” 和 “after B”<br>由上结果观察到：before A 与 A 间距 90px; A 与 B 间距 80px; B 与 after B 间距 80px;</p>
<p>错误的计算方式：算 A 和 B 之间的 margin，分别算 A 和其父元素的折叠，然后与其父元素的父元素的折叠，这个值算出来之后，应该是 90px。依此法算出 B 的为 80px；然后，A和B折叠，margin 为 90px。</p>
<p>请注意，多个 margin 相邻折叠成一个 margin，所以计算的时候，应该取所有相关的值一起计算，而不能分开分步来算。</p>
<p>以上例子中，A 和 B 之间的 margin 折叠产生的 margin，是6个相邻 margin 折叠的结果。将其 margin 值分为两组：</p>
<ul>
<li>正值：50px，150px，200px</li>
<li>负值：-60px，-100px，-120px<br>根据有正有负时的计算规则，正值的最大值为 200px，负值中绝对值最大的是 -120px，所以，最终折叠后的 margin 应该是 200 + (-120) = 80px。</li>
</ul>
<h4 id="不发生margin折叠的情况">不发生margin折叠的情况</h4>
<h3 id="浮动元素、inline-block_元素、绝对定位元素">浮动元素、inline-block 元素、绝对定位元素</h3>
<p><strong>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠</strong><br>浮动元素的 margin 在垂直方向上也不会发生 margin 折叠，即使和它相邻的子元素也不会。<br>DEMO-6(浮动元素margin不折叠):</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"margin-bottom:50px; width:50px; height:50px; background-color:green;"</span>&gt;</span>A<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"margin-top:50px; width:100px; height:100px; background-color:green; float:left;"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"margin-top:50px; background-color:gold;"</span>&gt;</span>B<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/w19dre3r/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>两个绿色的块儿之间，相距100px，显然B与A之间没有发生折叠，而若 B 和它的浮动包含块发生 margin 折叠的话，金色的条应该位于绿色块的最上方，显然，没有发生折叠。</p>
<h4 id="创建了块级格式化上下文的元素">创建了块级格式化上下文的元素</h4>
<p><strong>创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠</strong><br>块级格式化上下文:<a href="http://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank">http://www.w3.org/TR/CSS2/visuren.html#block-formatting</a><br>DEMO-7(以”overflow : hidden” 的元素为例):</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"margin-top:50px; width:100px; height:100px; background-color:green; overflow:hidden;"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"margin-top:50px; background-color:gold;"</span>&gt;</span>B<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/bkjyy0yg/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>若 B 和它的 “overflow:hidden” 包含块发生 margin 折叠的话，金色的条应该位于绿色块的最上方，此例中显然没有折叠。</p>
<h4 id="元素自身的margin折叠">元素自身的margin折叠</h4>
<p><strong>元素自身的 margin-bottom 和 margin-top 相邻时也会折叠</strong><br>自身 margin-bottom 和 margin-top 相邻，只能是自身内容为空，垂直方向上 border、padding 为 0。</p>
<p>DEMO-8(元素自身的 margin-bottom 和 margin-top折叠):</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"border:1px solid red; width:100px;"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"margin-top: 100px;margin-bottom: 50px;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/zn7yd2te/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>由上结果观察到：红框框里面的div的margin-bottom 和 margin-top折叠了，因为如果不折叠他的高会是150px，折叠之后它的高为100px。红色框框div的宽为100px，结果刚好是个正方形。</p>
<hr>
<h3 id="内容的尺寸与元素框的总尺寸">内容的尺寸与元素框的总尺寸</h3>
<p>在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p>假设框的每个边上有 10 个像素的外边距和 5 个像素的内边距。如果希望这个元素框达到 100 个像素，就需要将内容的宽度设置为 70 像素,请看下图。<br><img src="/img/CSS/boxmodelsize.gif" alt="盒模型"></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="id">#box</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">70</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10</span>px</span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>当你设置了元素的宽度，实际展现的元素却能够超出你的设置：因为元素的边框和内边距会撑开元素。<br>DEMO:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="class">.simple</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20</span>px auto</span></span>;
<span class="rule">}</span></span>

<span class="class">.fancy</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20</span>px auto</span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">50</span>px</span></span>;
  <span class="rule"><span class="attribute">border-width</span>:<span class="value"> <span class="number">10</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/sqhz2dqh/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>以前有一个代代相传的解决方案是数学。CSS开发者需要用比他们实际想要的宽度小一点的宽度，需要减去内边距和边框的宽度。值得庆幸地是你不需要再这么做了…</p>
<h3 id="CSS3属性：box-sizing">CSS3属性：box-sizing</h3>
<p>当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。这里有一个与上例相同的例子，唯一的区别是两个元素都设置了 box-sizing: border-box;<br>DEMO:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="class">.simple</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20</span>px auto</span></span>;
  <span class="rule"><span class="attribute">-webkit-box-sizing</span>:<span class="value"> border-box</span></span>;
     <span class="rule"><span class="attribute">-moz-box-sizing</span>:<span class="value"> border-box</span></span>;
          <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;
<span class="rule">}</span></span>

<span class="class">.fancy</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20</span>px auto</span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">50</span>px</span></span>;
  <span class="rule"><span class="attribute">border-width</span>:<span class="value"> <span class="number">10</span>px</span></span>;
  <span class="rule"><span class="attribute">-webkit-box-sizing</span>:<span class="value"> border-box</span></span>;
     <span class="rule"><span class="attribute">-moz-box-sizing</span>:<span class="value"> border-box</span></span>;
          <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/4vgsw2xu/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>此时两个div不含margin的width都为500px，这就和我们设置的值一样了。</p>
<p>既然没有比这更好的方法，一些CSS开发者想要页面上所有的元素都有如此表现。所以开发者们把以下CSS代码放在他们页面上：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>* <span class="rules">{
  <span class="rule"><span class="attribute">-webkit-box-sizing</span>:<span class="value"> border-box</span></span>;
     <span class="rule"><span class="attribute">-moz-box-sizing</span>:<span class="value"> border-box</span></span>;
          <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>这样可以确保所有的元素都会用这种更直观的方式排版。</p>
<p>既然 box-sizing 是个很新的属性，目前你还应该像我之前在例子中那样使用 -webkit- 和 -moz- 前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+。</p>
<hr>
<h2 id="position属性">position属性</h2>
<h3 id="position属性值">position属性值</h3>
<p><strong>static</strong><br>元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。<br>DEMO-1(static)：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class">.static</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> static</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/oeyc2bu6/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>relative</strong><br>元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。<br>DEMO-2(relative)：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="class">.relative1</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
<span class="rule">}</span></span>
<span class="class">.relative2</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> -<span class="number">20</span>px</span></span>;
  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">20</span>px</span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> white</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/82agccp1/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>absolute</strong><br>元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。<br>absolute 是最棘手的position值。 absolute 与 fixed 的表现类似，除了它不是相对于视窗而是相对于最近的“positioned”祖先元素。<br>如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 html 标签 (参考的文档说是相对于文档的 body 元素，之后我将会说为什么我认为是相对html标签)，并且它会随着页面滚动而移动。<br>记住一个“positioned”元素是指position 值不是 static 的元素。<br>DEMO-3(absolute)：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class">.relative</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">600</span>px</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">400</span>px</span></span>;
<span class="rule">}</span></span>
<span class="class">.absolute</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">120</span>px</span></span>;
  <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300</span>px</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">200</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/ucn9nwxw/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>为什么上面我说绝对定位子元素在没有“positioned”祖先元素时是相对 html 标签 而不是 body元素呢？我们修改一下上例把position:relative 的div 改成 position:static,结果如下：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/yys8bo4z/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>absolute的元素的top为120px;以下截图一目了然：<br><img src="/img/CSS/position-absolute1.png" alt="position-absolute1"><br><img src="/img/CSS/position-absolute2.png" alt="position-absolute2"><br>所以我认为是相对于html标签才对。。。</p>
<p><strong>fixed</strong><br>元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。即便页面滚动，它还是会停留在相同的位置。<br>DEMO-4(fixed)：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class">.fixed</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;
  <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> white</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/thg4otsx/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>一个固定定位元素不会保留它原本在页面应有的空隙。</p>
<p>令人惊讶地是移动浏览器对 fixed 的支持很差。<a href="http://bradfrostweb.com/blog/mobile/fixed-position/" target="_blank">这里有相应的解决方案</a>。</p>
<h3 id="position例子-左固定宽度，右自适应宽度">position例子-左固定宽度，右自适应宽度</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="class">.container</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
<span class="rule">}</span></span>
<span class="tag">nav</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span>px</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
<span class="rule">}</span></span>
<span class="tag">section</span> <span class="rules">{
  <span class="comment">/* position is static by default */</span>
  <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">200</span>px</span></span>;
<span class="rule">}</span></span>
<span class="tag">footer</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;
  <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">70</span>px</span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> white</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100</span>%</span></span>;
<span class="rule">}</span></span>
<span class="tag">body</span> <span class="rules">{
  <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">120</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/kcywvs2z/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>这个例子在容器比nav元素高的时候可以正常工作。如果容器比nav元素低，那么nav会溢出到容器的外面。之后我们会讨论下其他布局技术，它们都各有优劣。</p>
<hr>
<h2 id="float">float</h2>
<p>float很熟悉了，不举例了。可以用作文字环绕图片，float布局很常用。<br>其中、最棘手的应该算是清除浮动了。</p>
<h3 id="如何清除浮动？">如何清除浮动？</h3>
<h3 id="float例子-左固定宽度，右自适应宽度">float例子-左固定宽度，右自适应宽度</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">nav</span> <span class="rules">{
  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
<span class="rule">}</span></span>
<span class="tag">section</span> <span class="rules">{
  <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">200</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>给最外的框框添加清除浮动的class：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class">.clearfix</span><span class="pseudo">:after</span> <span class="rules">{
    <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">"."</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/x2xjLpae/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="百分比宽度">百分比宽度</h2>
<p>百分比是一种相对于包含块的计量单位。它对图片很有用：如下我们实现了图片宽度始终是容器宽度的50%。把页面缩小看下效果！</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">article</span> <span class="tag">img</span> <span class="rules">{
  <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50</span>%</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>图片要放在文字前哦。不然就没有图片在文字右边这种效果啦…<br>再复习一遍，别忘了给article元素加清除浮动的class：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class">.clearfix</span><span class="pseudo">:after</span> <span class="rules">{
    <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">"."</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/tw97t7xa/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h3 id="百分比宽度布局-左固定百分比右自适应">百分比宽度布局-左固定百分比右自适应</h3>
<p>在下面的例子中，当窗口宽度很窄时 nav 的内容会以一种不太友好的方式被包裹起来。总而言之，选一种最合适你的内容的方式。<br>下面例子 与 float例子-左固定宽度，右自适应宽度 这个例子基本一样，就是把像素换成百分比。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">nav</span> <span class="rules">{
  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">25</span>%</span></span>;
<span class="rule">}</span></span>
<span class="tag">section</span> <span class="rules">{
  <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">25</span>%</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>还是别忘了清除浮动。</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/5hbse4vw/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>以上做法不是很优雅，接下来来看一种更酷的做法~</p>
<h2 id="媒体查询">媒体查询</h2>
<p>“响应式设计（Responsive Design）”是一种让网站针对不同的浏览器和设备“响应”不同显示效果的策略，这样可以让网站在任何情况下显示的很棒！</p>
<p>媒体查询是做此事所需的最强大的工具。让我们使用百分比宽度来布局，然后在浏览器变窄到无法容纳侧边栏中的菜单时，把布局显示成一列：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> screen and (min-width:<span class="number">600</span>px) </span>{
  <span class="tag">nav</span> <span class="rules">{
    <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">25</span>%</span></span>;
  <span class="rule">}</span></span>
  <span class="tag">section</span> <span class="rules">{
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">25</span>%</span></span>;
  <span class="rule">}</span></span>
}
<span class="at_rule">@<span class="keyword">media</span> screen and (max-width:<span class="number">599</span>px) </span>{
  <span class="tag">nav</span> <span class="tag">li</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>;
  <span class="rule">}</span></span>
}
</pre></td></tr></table></figure>

<p>还是别忘了清除浮动。</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/pmxd2gtq/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>当屏幕宽度大于等于 600px 时会使用这段CSS:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> screen and (min-width:<span class="number">600</span>px) </span>{
  <span class="tag">nav</span> <span class="rules">{
    <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">25</span>%</span></span>;
  <span class="rule">}</span></span>
  <span class="tag">section</span> <span class="rules">{
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">25</span>%</span></span>;
  <span class="rule">}</span></span>
}
</pre></td></tr></table></figure>

<p>否则将使用这段CSS:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> screen and (max-width:<span class="number">599</span>px) </span>{
  <span class="tag">nav</span> <span class="tag">li</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>;
  <span class="rule">}</span></span>
}
</pre></td></tr></table></figure>

<p>现在我们的布局在移动浏览器上也显示的很棒。这里有一些 <a href="http://mediaqueri.es/" target="_blank">同样使用了媒体查询的著名站点</a>。在<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries" target="_blank">MDN文档</a>中你还可以学到更多有关媒体查询的知识。</p>
<p><strong>另</strong>：使用 <a href="http://dev.opera.com/articles/an-introduction-to-meta-viewport-and-viewport/" target="_blank">meta viewport</a> 之后可以让你的布局在移动浏览器上显示的更好。关于移动web的总结实践我将在不久的将来整理 O(∩_∩)O~</p>
<hr>
<h2 id="inline-block">inline-block</h2>
<p>你可以创建很多网格来铺满浏览器。在过去很长的一段时间内使用 float 是一种选择，但是使用 inline-block 会更简单。让我们看下使用这两种方法的例子：</p>
<p><strong>困难的方式（使用浮动）：</strong></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class">.box</span> <span class="rules">{
  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1</span>em</span></span>;
<span class="rule">}</span></span>
<span class="class">.after-box</span> <span class="rules">{
  <span class="rule"><span class="attribute">clear</span>:<span class="value"> left</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/ksLh608q/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>容易的方式（使用 inline-block）：</strong></p>
<p>你可以用 display 属性的值 inline-block 来实现相同效果。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="class">.box2</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100</span>px</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1</span>em</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/qgbqfxd2/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>了解更多：<a href="https://blog.mozilla.org/webdev/2009/02/20/cross-browser-inline-block/" target="_blank">IE6和IE7支持 inline-block</a></p>
<h3 id="inline-block_布局-左固定百分比右自适应">inline-block 布局-左固定百分比右自适应</h3>
<p>使用 inline-block 来布局。有一些事情需要你牢记：</p>
<ul>
<li>vertical-align 属性会影响到 inline-block 元素，你可能会把它的值设置为 top 。</li>
<li>你需要设置每一列的宽度</li>
<li>如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙</li>
</ul>
<p>DEMO:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="tag">nav</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
  <span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> top</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">25</span>%</span></span>;
<span class="rule">}</span></span>
<span class="class">.column</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
  <span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> top</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">75</span>%</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/sbct65Lo/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>



<h2 id="CSS3属性-column">CSS3属性-column</h2>
<p>这里有一系列新的CSS属性，可以帮助你很轻松的实现文字的多列布局。让我们瞧瞧：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class">.three-column</span> <span class="rules">{
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1</span>em</span></span>;
  <span class="rule"><span class="attribute">-moz-column-count</span>:<span class="value"> <span class="number">3</span></span></span>;
  <span class="rule"><span class="attribute">-moz-column-gap</span>:<span class="value"> <span class="number">1</span>em</span></span>;
  <span class="rule"><span class="attribute">-webkit-column-count</span>:<span class="value"> <span class="number">3</span></span></span>;
  <span class="rule"><span class="attribute">-webkit-column-gap</span>:<span class="value"> <span class="number">1</span>em</span></span>;
  <span class="rule"><span class="attribute">column-count</span>:<span class="value"> <span class="number">3</span></span></span>;
  <span class="rule"><span class="attribute">column-gap</span>:<span class="value"> <span class="number">1</span>em</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/5wt4bc6j/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>CSS columns是很新的标准，所以你需要使用前缀，并且它不被<a href="http://caniuse.com/#search=column" target="_blank">IE9及以下和Opera Mini</a>支持。还有许多和 cloumn 相关的属性，<a href="http://quirksmode.org/css/columns/" target="_blank">点击这里了解更多</a>。</p>
<h2 id="flexbox">flexbox</h2>
<p>新的 flexbox 布局模式被用来重新定义CSS中的布局方式。很遗憾的是最近规范变动过多，导致各个浏览器对它的实现也有所不同。不过我仍旧想要分享一些例子，来让你知道即将发生的改变。这些例子目前只能在支持 flexbox 的 Chrome 浏览器中运行，基于 <a href="http://www.w3.org/TR/css3-flexbox/" target="_blank">最新的标准</a>。</p>
<p>网上有不少过时的 flexbox 资料。 如果你想要了解更多有关 flexbox 的内容，<a href="http://css-tricks.com/old-flexbox-and-new-flexbox/" target="_blank">从这里</a>学习如何辨别一份资料是否过时。此参考文献作者已经写了一份<a href="http://bocoup.com/weblog/dive-into-flexbox/" target="_blank">关于最新标准的详细文章</a>。</p>
<p>使用flexbox你还可以做的更多；这里只是一些让你了解概念的例子：</p>
<h3 id="使用_Flexbox_的简单布局">使用 Flexbox 的简单布局</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="class">.container</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-flex</span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
<span class="rule">}</span></span>
<span class="tag">nav</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
<span class="rule">}</span></span>
<span class="class">.flex-column</span> <span class="rules">{
  <span class="rule"><span class="attribute">-webkit-flex</span>:<span class="value"> <span class="number">1</span></span></span>;
          <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span></span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/s6643new/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h3 id="使用_Flexbox_的牛逼布局">使用 Flexbox 的牛逼布局</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="class">.container</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-flex</span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
<span class="rule">}</span></span>
<span class="class">.initial</span> <span class="rules">{
  <span class="rule"><span class="attribute">-webkit-flex</span>:<span class="value"> initial</span></span>;
          <span class="rule"><span class="attribute">flex</span>:<span class="value"> initial</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
  <span class="rule"><span class="attribute">min-width</span>:<span class="value"> <span class="number">100</span>px</span></span>;
<span class="rule">}</span></span>
<span class="class">.none</span> <span class="rules">{
  <span class="rule"><span class="attribute">-webkit-flex</span>:<span class="value"> none</span></span>;
          <span class="rule"><span class="attribute">flex</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px</span></span>;
<span class="rule">}</span></span>
<span class="class">.flex1</span> <span class="rules">{
  <span class="rule"><span class="attribute">-webkit-flex</span>:<span class="value"> <span class="number">1</span></span></span>;
          <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.flex2</span> <span class="rules">{
  <span class="rule"><span class="attribute">-webkit-flex</span>:<span class="value"> <span class="number">2</span></span></span>;
          <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">2</span></span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/prg6gac9/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h3 id="使用_Flexbox_的居中布局">使用 Flexbox 的居中布局</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="class">.vertical-container</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-flex</span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300</span>px</span></span>;
<span class="rule">}</span></span>
<span class="class">.vertically-centered</span> <span class="rules">{
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/6pjedh20/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<hr>
<p>参考文献：<br><a href="http://zh.learnlayout.com" target="_blank">[1] 学习CSS布局</a><br><a href="http://w3help.org/zh-cn/kb/006/" target="_blank">[2] CSS 框模型( Box module )</a><br><a href="http://w3help.org/zh-cn/kb/006/" target="_blank">[3] CSS 框模型概述</a><br><a href="http://www.w3school.com.cn/css/css_boxmodel.asp" target="_blank">[4] 网页布局基础</a></p>
]]></content>
    
    
      <category term="CSS" scheme="http://snailsky.me/tags/CSS/"/>
    
      <category term="总结" scheme="http://snailsky.me/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="CSS" scheme="http://snailsky.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【CSS】浮动和它的工作原理？清除浮动的技巧？]]></title>
    <link href="http://snailsky.me/2014/08/20/%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9F/"/>
    <id>http://snailsky.me/2014/08/20/浮动和它的工作原理？清除浮动的技巧？/</id>
    <published>2014-08-20T08:46:45.000Z</published>
    <updated>2014-09-15T10:39:33.000Z</updated>
    <content type="html"><![CDATA[<p>学习总结浮动和它的工作原理，及清除浮动的方法及原理集锦。探索浮动与清除浮动的奥妙。</p>
<hr>
<h2 id="浮动和它的工作原理">浮动和它的工作原理</h2>
<p>“浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。<br>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。”</p>
<p>— <a href="http://www.w3school.com.cn/css/css_positioning_floating.asp" target="_blank">W3School</a></p>
<p>浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。</p>
<hr>
<h3 id="浮动布局：">浮动布局：</h3>
<ul>
<li>浮动布局是CSS中规定的第二种定位机制。 (<a href="http://www.w3school.com.cn/css/css_positioning.asp" target="_blank">CSS 有三种基本的定位机制：普通流、浮动和绝对定位。</a>)</li>
<li>能够实现横向多列布局。（常见的为横向两列布局，横向三列布局）</li>
<li>通过设置float属性实现。</li>
</ul>
<hr>
<h3 id="float属性：">float属性：</h3>
<p><em>3个属性值</em>：</p>
<ul>
<li>left   -  左浮动</li>
<li>right -  右浮动</li>
<li>none  -  不浮动</li>
</ul>
<p><em>特点</em>：<br>元素会左移，或右移，直至触碰到容器为止。<br><em>设置了浮动的元素仍旧处于标准文档流中。</em>会占据标准文档流空间，对其他元素有影响。</p>
<p>浮动DEMO-1 (box1左浮动)：</p>
<iframe width="100%" height="150" src="http://jsfiddle.net/snbdxb77/1/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>上例box1设置了float:left; 和 height:100px;<br>当box1没有内容的时候,float:left;的作用使得此div尺寸得不到扩展，将缩成一个小圆点出现在body标签的左上角。<br>box1沿着它的容器(此例中box1的容器为body标签)左浮动。</p>
<p>浮动DEMO-2 (box1左浮动)：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/f50po7oc/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>浮动DEMO-3 (box1左浮动,box2右浮动)：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/u20Lgvw6/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>浮动DEMO-4 (box1左浮动,box2左浮动)：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/0wrnqpqf/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>浮动DEMO-5 (box1,box2都不浮动，且都在class=”wrap”的div容器中)：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/zq4z8sgL/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>浮动DEMO-6 (box1,box2左浮动，且都在class=”wrap”的div容器中)：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/uatxp09q/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>浮动DEMO-5、浮动DEMO-6 观察class=”wrap”的元素的黑色的border，DEMO-5中的wrap为正常高度，DEMO-6中wrap的高度为0。</p>
<p><em>为什么会出现“高度塌陷”这样的现象？</em></p>
<p>我们先看看什么是浮动：<br>浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。</p>
<p>正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。</p>
<p><em>总结</em>：</p>
<ul>
<li>当元素没有设置宽度值，而设置了浮动属性，元素的宽度随内容的宽度的变化而变化。</li>
<li>当元素设置浮动属性后，会对相邻的元素产生影响，相邻元素特指紧邻后面的元素。</li>
<li>当一个包含框中的元素全设置了浮动时，改包含框会出现“高度塌陷”现象。</li>
</ul>
<p><em>思考</em>：<br>当设置浮动元素时，紧邻其后的元素会受到浮动元素的影响，且其父元素可能出现高度塌陷，这样可能会使布局错乱，所以我们需要想办法来清除浮动。</p>
<hr>
<h2 id="怎样清除浮动呢？">怎样清除浮动呢？</h2>
<p>首先我们先弄清楚一下概念，其实大家习惯称为“清除浮动”实际上应该称作“闭合浮动”。</p>
<ul>
<li>清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none；</li>
<li>闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。</li>
</ul>
<p>我们想要达到的效果确切的说是闭合浮动，而不是单纯的清除浮动，单纯的清除浮动，并不能解决容器高度塌陷的问题。</p>
<hr>
<h3 id="闭合浮动的方法：">闭合浮动的方法：</h3>
<h4 id="方法一（差）：添加额外标签">方法一（差）：添加额外标签</h4>
<p>在浮动元素末尾添加一个新标签，例如：<br>&lt;div style=”clear:both;”&gt;&lt;/div&gt;  (清除float:left 和 float:right的影响)<br>&lt;div style=”clear:left;”&gt;&lt;/div&gt;  (清除float:left的影响，如果是float:right造成的浮动影响这样写无用)<br>&lt;div style=”clear:right;”&gt;&lt;/div&gt; (清除float:right的影响，如果是float:left造成的浮动影响这样写无用)<br>其他标签br等亦可，看情况加入n个br标签(极不推荐，因为高度变了，代码也要变，维护起来要抓狂的)</p>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/8v4hnst4/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>优点</strong>：通俗易懂，容易掌握<br><strong>缺点</strong>：将添加很多无意义的空标签，有违结构与表现的分离，后期维护会是噩梦。</p>
<h4 id="方法二（差）：使用br标签及自身html属性">方法二（差）：使用br标签及自身html属性</h4>
<p>这个方法有些小众，br 有 clear=“all | left | right | none” 属性<br>&lt;br clear=”all” /&gt;  (清除float:left 和 float:right的影响)<br>&lt;br clear=”left “ /&gt;  (清除float:left的影响，如果是float:right造成的浮动影响这样写无用)<br>&lt;br clear=”right” /&gt; (清除float:right的影响，如果是float:left造成的浮动影响这样写无用)</p>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/skbkr76d/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>优点</strong>：比空标签方式语义稍强，代码量较少<br><strong>缺点</strong>：同样有违结构与表现的分离，不推荐使用</p>
<h4 id="方法三（差）：父元素设置overflow属性">方法三（差）：父元素设置overflow属性</h4>
<p>通过设置父元素overflow值设置为hidden;在IE6中还需要触发hasLayout，例如zoom：1;</p>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/oudou0uv/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>通过设置父元素overflow值设置为auto;在IE6中还需要触发hasLayout，例如zoom：1;</p>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/nwsqafLt/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>优点</strong>：不存在结构和语义化问题，代码量极少<br><strong>缺点</strong>：overflow:hidden; 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；不要使用<br>overflow:auto; 多层嵌套后，firefox与IE 可能会出现显示错误；不要使用</p>
<h4 id="方法四（差）：父元素也设置浮动">方法四（差）：父元素也设置浮动</h4>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/czfcank0/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>优点</strong>：不存在结构和语义化问题，代码量极少<br><strong>缺点</strong>：使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body，不推荐使用</p>
<h4 id="方法五（差）：父元素设置display:table">方法五（差）：父元素设置display:table</h4>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/4jm62zr2/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>优点</strong>：结构语义化完全正确，代码量极少<br><strong>缺点</strong>：盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用</p>
<h4 id="方法六（可）：使用:after伪元素">方法六（可）：使用:after伪元素</h4>
<p><a href="http://www.w3school.com.cn/cssref/pr_pseudo_after.asp" target="_blank">:after 伪元素在元素之后添加内容。</a><br>IE6-7不支持:after,使用zoom:1触发 hasLayout。<br>详细请看：<a href="http://www.positioniseverything.net/easyclearing.html" target="_blank">How To Clear Floats Without Structural Markup</a></p>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/pqz7y0m4/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>1) display:block 使生成的元素以块级元素显示,占满剩余空间;<br>2) height:0 避免生成内容破坏原有布局的高度。<br>3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;<br>4）通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX”,有些版本可能content 里面内容为空,不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙；<br>5）zoom：1 触发IE hasLayout。<br>通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。</p>
<p>优化方案一：<br>相对于空标签闭合浮动的方法代码似乎还是有些冗余，通过查询发现Unicode字符里有一个“零宽度空格”，也就是<a href="http://www.fileformat.info/info/unicode/char/200b/index.htm" target="_blank">U+200B</a>，这个字符本身是不可见的，所以我们完全可以省略掉 visibility:hidden了</p>
<p>DEMO:</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/running_snail/ruym187v/embedded/result,js,html,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>优化方案二：<br>参看：<a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank">A new micro clearfix hack</a></p>
<p><strong>优点</strong>：结构和语义化完全正确,代码量居中<br><strong>缺点</strong>：复用方式不当会造成代码量增加</p>
<hr>
<h3 id="闭合浮动的原理：">闭合浮动的原理：</h3>
<p>以上方法，分为两类：</p>
<ol>
<li>在浮动元素末尾添加一个空元素 (方法一，二，六)</li>
<li>设置父元素overflow 或者 display:table 来闭合浮动 (方法三，四，五)</li>
</ol>
<p>为什么设置父元素overflow 或者 display:table 可以闭合浮动?<br>其原理为<br><a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting" target="_blank"> Block formatting contexts </a>（块级格式化上下文），以下简称 BFC。<br>CSS3里面对这个规范做了改动，称之为：<a href="http://www.w3.org/TR/css3-box/#block-level0" target="_blank"> flow root </a>，并且对触发条件进行了进一步说明。</p>
<p><strong>如何触发BFC?</strong></p>
<ul>
<li>float 除了none以外的值</li>
<li>overflow 除了visible 以外的值（hidden，auto，scroll ）</li>
<li>display (table-cell，table-caption，inline-block)</li>
<li>position（absolute，fixed）</li>
<li>fieldset元素</li>
</ul>
<p>需要注意的是，display:table 本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。<br>fieldset 元素在www.w3.org里目前没有任何有关这个触发行为的信息，直到HTML5标准里才出现。有些浏览器bugs（Webkit，Mozilla）提到过这个触发行为，但是没有任何官方声明。实际上，即使fieldset在大多数的浏览器上都能创建新的块级格式化上下文，开发者也不应该把这当做是理所当然的。CSS 2.1没有定义哪种属性适用于表单控件，也没有定义如何使用CSS来给它们添加样式。用户代理可能会给这些属性应用CSS属性，建议开发者们把这种支持当做实验性质的，更高版本的CSS可能会进一步规范这个。</p>
<p>BFC的特性：</p>
<ul>
<li>块级格式化上下文会阻止外边距叠加<br>当两个相邻的块框在同一个块级格式化上下文中时，它们之间垂直方向的外边距会发生叠加。换句话说，如果这两个相邻的块框不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。</li>
<li>块级格式化上下文不会重叠浮动元素<br>根据规定，一个块级格式化上下文的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给块级格式化上下文创建隐式的外边距来阻止它和浮动元素的外边距叠加。由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用（Webkit和IE6在这点上有一个问题——可以看这个测试用例）。</li>
<li>块级格式化上下文通常可以包含浮动<br>详见： W3C CSS2.1 - 10.6.7 <a href="http://www.w3.org/TR/CSS2/visudet.html#root-height" target="_blank">‘Auto’ heights for block formatting context roots</a></li>
</ul>
<p>通俗地来说：创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。<br>overflow:hidden或者auto可以闭合浮动，就是因为父元素创建了新的BFC。</p>
<p>IE专有属性hadLayout，没有做过IE 不了解，关于hadLayout来这看：<a href="http://www.smallni.com/haslayout-block-formatting-contexts/" target="_blank">hasLayout &amp;&amp; Block Formatting Contexts</a></p>
<hr>
<p>参考文献：<br><a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank">[1] 那些年我们一起清除过的浮动</a><br><a href="http://www.yuiblog.com/blog/2010/05/19/css-101-block-formatting-contexts" target="_blank">[2] CSS 101: Block Formatting Contexts</a><br><a href="http://stackoverflow.com/questions/211383/which-method-of-clearfix-is-best" target="_blank">[3] Which method of ‘clearfix’ is best? - Stack Overflow</a></p>
]]></content>
    
    
      <category term="CSS" scheme="http://snailsky.me/tags/CSS/"/>
    
      <category term="原理" scheme="http://snailsky.me/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="技巧" scheme="http://snailsky.me/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="stackoverflow" scheme="http://snailsky.me/tags/stackoverflow/"/>
    
      <category term="CSS" scheme="http://snailsky.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【CSS】display:none 和 visibility:hidden 有何区别？]]></title>
    <link href="http://snailsky.me/2014/08/18/displaynone-%E5%92%8C-visibilityhidden-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://snailsky.me/2014/08/18/displaynone-和-visibilityhidden-有何区别？/</id>
    <published>2014-08-18T13:09:51.000Z</published>
    <updated>2014-09-15T10:39:43.000Z</updated>
    <content type="html"><![CDATA[<p>在使用CSS隐藏一些元素时，常常用到 display:none 和 visibility:hidden<br>两者差别在哪儿？</p>
<h2 id="比较与实例">比较与实例</h2>
<h3 id="空间占据:">空间占据:</h3>
<p><em>display:none</em><br>隐藏后的元素不占据任何空间。它的宽度、高度等各种属性值都将“丢失”。<br><em>visibility:hidden</em><br>隐藏的元素空间依旧存在。它仍具有高度、宽度等属性值。</p>
<p><em>在线演示实例</em>：</p>
<iframe style="width: 100%; height: 300px" src="http://sandbox.runjs.cn/show/sxcwid89" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<hr>
<h3 id="前端性能:">前端性能:</h3>
<p><em>display:none</em><br>会触发reflow。<br><em>visibility:hidden</em><br>只会触发repaint，因为没有发现位置变化。</p>
<p><em>什么是reflow和repaint？</em>:<br>浏览器渲染时,JavaScript动态修改了DOM属性或是CSS属性会导致重新Layout，<br>有些改变不会，比如CSS rule没有被匹配到，等</p>
<p>这里比较重要的两个概念是 reflow（回流） 和 repaint（重绘）他们不是一回事。</p>
<ul>
<li>Repaint——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。</li>
<li>Reflow——意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow）reflow 会从<html>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</li>
</ul>
<p>详情请看：<a href="http://coolshell.cn/articles/9666.html" target="_blank">浏览器的渲染原理简介</a></p>
<hr>
<h3 id="对子元素的影响:">对子元素的影响:</h3>
<p><em>display:none</em><br>一旦父节点元素应用了display:none，父节点及其子孙节点元素全部不可见，而且无论其子孙元素如何不屈地挣扎都无济于事。<br><em>visibility:hidden</em><br>给一个父元素应用visibility:hidden，则其子孙后代也都会全部不可见。不过存在隐藏“失效”的情况。当其子孙元素应用了visibility:visible，那么这个子孙元素又会显现出来。</p>
<hr>
<h3 id="是否加载？">是否加载？</h3>
<p>Q1:页面加载完毕后，浏览器会下载“mypic.jpg”图片吗？</p>
<p><em>HTML</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test1"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p><em>CSS</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="id">#test2</span> <span class="rules">{
    <span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">url(<span class="string">'mypic.jpg'</span>)</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>在jsfiddle上试了以上代码没有图片，但是可以通过Chrome开发者工具观察到，是否发送了加载图片的请求<br><img src="/img/CSS/1.jpg" alt="display:none"><br>答案是 YES。</p>
<hr>
<p>Q2:页面加载完毕后，浏览器会下载“mypic.jpg”图片吗？</p>
<p><em>HTML</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test1"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p><em>CSS</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="id">#test2</span> <span class="rules">{
    <span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">url(<span class="string">'mypic.jpg'</span>)</span></span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p><img src="/img/CSS/1.jpg" alt="display:none"><br>答案是 YES。</p>
<hr>
<p>Q3:页面加载完毕后，浏览器会下载“mypic.jpg”图片吗？</p>
<p><em>HTML</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test1"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p><em>CSS</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="id">#test1</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;
<span class="rule">}</span></span>
<span class="id">#test2</span> <span class="rules">{
    <span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">url(<span class="string">'mypic.jpg'</span>)</span></span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p><img src="/img/CSS/2.jpg" alt="display:none"><br>答案是 NO。</p>
<p><em>经试验可猜测</em>：样式中带有 display:none 和 visibility:hidden 的元素会被加载<br>不过display:none的子元素不会被加载。</p>
<hr>
<p>参考文献：<br><a href="http://blog.jobbole.com/12749/" target="_blank">[1] 现代浏览器的工作原理</a><br><a href="http://coolshell.cn/articles/9666.html" target="_blank">[2] 浏览器的渲染原理简介</a><br><a href="http://www.zhangxinxu.com/wordpress/2012/02/css-overflow-hidden-visibility-hidden-disabled-use/" target="_blank">[3] 您可能不知道的CSS元素隐藏“失效”以其妙用</a><br><a href="http://davidshariff.com/quiz/" target="_blank">[4] Front End Web Development Quiz</a></p>
]]></content>
    
    
      <category term="CSS" scheme="http://snailsky.me/tags/CSS/"/>
    
      <category term="区别" scheme="http://snailsky.me/tags/%E5%8C%BA%E5%88%AB/"/>
    
      <category term="原理" scheme="http://snailsky.me/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="stackoverflow" scheme="http://snailsky.me/tags/stackoverflow/"/>
    
      <category term="CSS" scheme="http://snailsky.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[那些年被我们误用的CSS选择器]]></title>
    <link href="http://snailsky.me/2014/07/22/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%A2%AB%E6%88%91%E4%BB%AC%E8%AF%AF%E7%94%A8%E7%9A%84CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://snailsky.me/2014/07/22/那些年被我们误用的CSS选择器/</id>
    <published>2014-07-22T14:57:11.000Z</published>
    <updated>2014-08-24T11:21:12.000Z</updated>
    <content type="html"><![CDATA[<p>曾几何时，我天真的认为“选择器肯定是越详细，层数越多越好呗”。现在觉得自己以前真是图样图森破…<br>谨以此文，祭奠那些被我误用的CSS, orz。<br>此文重在讨论<em>如何书写高效的CSS选择器</em>。如有错误，欢迎指正，O(∩_∩)O</p>
<hr>
<h2 id="浏览如何识别选择器？">浏览如何识别选择器？</h2>
<p>“浏览器读取选择器的顺序是由右到左进行”—<a href="http://css-tricks.com/efficiently-rendering-css/" target="_blank">《Efficiently Rendering CSS》Chris Coyier</a></p>
<p>例如：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">ul</span> &gt; <span class="tag">li</span> <span class="tag">a</span><span class="attr_selector">[title="home"]</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure><br>浏览器将首先解释 a[title=”home”]。这个最先解释选择器是最后被选择的元素的“关键选择器”。<br><br>再如：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">a</span> <span class="tag">img</span>, <span class="tag">div</span> &gt; <span class="tag">p</span>, <span class="tag">h1</span> + <span class="attr_selector">[title]</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure><br>此处关键选择器为 img，p，title<br><br>关键选择器示例：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="id">#main-navigation</span> <span class="rules">{<span class="rule">…}</span></span>            <span class="comment">/* ID (Fastest) */</span>
<span class="tag">body</span><span class="class">.home</span> <span class="id">#page-wrap</span> <span class="rules">{<span class="rule">…}</span></span>        <span class="comment">/* ID */</span>
<span class="class">.main-navigation</span> <span class="rules">{<span class="rule">…}</span></span>            <span class="comment">/* Class */</span>
<span class="tag">ul</span> <span class="tag">li</span> <span class="tag">a</span><span class="class">.current</span> <span class="rules">{<span class="rule">…}</span></span>             <span class="comment">/* Class *
ul {…}                          /* Tag */</span>
<span class="tag">ul</span> <span class="tag">li</span> <span class="tag">a</span> <span class="rules">{<span class="rule">…}</span></span>                     <span class="comment">/* Tag */</span>
* <span class="rules">{<span class="rule">…}</span></span>                           <span class="comment">/* Universal (Slowest) */</span>
<span class="id">#content</span> <span class="attr_selector">[title='home']</span> <span class="rules">{<span class="rule">…}</span></span>     <span class="comment">/* Universal */</span>
</pre></td></tr></table></figure>

<p><em>越具体的关键选择器，其性能越高。 </em></p>
<h2 id="如何写有效率的CSS选择器？">如何写有效率的CSS选择器？</h2>
<h3 id="选择器效率排序">选择器效率排序</h3>
<p>选择器效率从高到低排列如下</p>
<ul>
<li>id选择器（#myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div,h1,p）</li>
<li>相邻选择器（h1+p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（*）</li>
<li>属性选择器（a[rel=”external”]）</li>
<li>伪类选择器（a:hover,li:nth-child）</li>
</ul>
<h3 id="一些写高效CSS选择器的规则">一些写高效CSS选择器的规则</h3>
<h4 id="不要在ID选择器前加标签名或类">不要在ID选择器前加标签名或类</h4>
<p>如果一个规则的关键选择器是ID选择器，不要在其前面加上标签名或类名。因为ID是唯一的加上一个标签名会降低匹配速度。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">button</span><span class="id">#backButton</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#backButton</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>



<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.menu-left</span><span class="id">#newMenuIcon</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#newMenuIcon</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<h4 id="不要在类前加标签名">不要在类前加标签名</h4>
<p>之前的观念依然适用，虽然类可在同个页面中被使用多次，但他们仍比标签稀罕。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">div</span>.indented <span class="tuple">{…}</span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD  (tag+class命名法 缺点是不够灵活，如果改了标签类名也要换)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>.<span class="keyword">div</span>-indented <span class="tuple">{…}</span>
</pre></td></tr></table></figure>

<ul>
<li>BEST  (语义化的类名使其更灵活)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.hierarchy-deep</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<h4 id="尽可能使用最具体的类别">尽可能使用最具体的类别</h4>
<ul>
<li>BAD (太多的规则导致查找速度变慢)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">a</span><span class="attr_selector">[target=_blank]</span> &gt; <span class="tag">p</span> &gt; <span class="tag">span</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">.</span>span<span class="attribute">-target</span><span class="attribute">-blank</span> {…}
</pre></td></tr></table></figure>

<h4 id="避免使用后代选择器">避免使用后代选择器</h4>
<p><em>后代选择器是CSS中代价最昂贵的选择器。</em>尤其是标签或是通配符选择器，它将昂贵的可怕。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">table</span> tbody tr th {…}
</pre></td></tr></table></figure>

<ul>
<li>BETTER,BUT STILL BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">table</span> &gt; tbody &gt; tr &gt; th {…}
</pre></td></tr></table></figure>

<h4 id="标签分类规则不应该包含子元素选择器">标签分类规则不应该包含子元素选择器</h4>
<p>避免在标签类型规则使用子元素选择器。这会使匹配时间增多。</p>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">table</span> &gt; tbody &gt; tr &gt; th {…}
</pre></td></tr></table></figure>

<ul>
<li>GOOD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>.th-<span class="built_in">table</span> {…}
</pre></td></tr></table></figure>

<h4 id="避免使用通配符选择器">避免使用通配符选择器</h4>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.selected</span> * <span class="rules">{<span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>浏览器会匹配文档中所有元素，然后分别向上逐级匹配class为selected的元素，<br>知道文档的根节点，因此匹配花销是非常大的，通常比开销最小的ID选择器高出1~3个数量级，所以应避免使用关键选择器是通配选择器的规则。</p>
<h4 id="避免使用单规则的选择器">避免使用单规则的选择器</h4>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class">.selected</span> <span class="attr_selector">[href=”#index”]</span> <span class="rules">{<span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>其匹配开销是非常大的，浏览器先匹配所有的元素，检查其是否有href属性并且herf属性值等于”#index”， 然后分别向上逐级匹配class为selected的元素，直到文档的根节点。所以应避免使用关键选择器是单规则属性选择器的规则。</p>
<h4 id="避免使用类正则的选择器">避免使用类正则的选择器</h4>
<p>CSS3添加了复杂的属性选择器，可以通过类正则表达式的方式对元素的属性值进行匹配。当然这些类型的选择器定是会影响性能的，正则表达式匹配会比基于类别的匹配会慢很多。大部分情况下我们应尽量避免使用 *=， |=， ^=， $=， 和 ~=语法的属性选择器。</p>
<h4 id="适当调整你的选择器">适当调整你的选择器</h4>
<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#main-navigation</span> <span class="tag">li</span> <span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">font-family</span>:<span class="value"> Georgia, Serif</span></span>; <span class="rule">}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD (如果你需要的只是改变字体，这样写可能更有效)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#main-navigation</span> <span class="rules">{ <span class="rule"><span class="attribute">font-family</span>:<span class="value"> Georgia, Serif</span></span>; <span class="rule">}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>BAD</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#nav</span> <span class="tag">li</span> <span class="tag">a</span> <span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<ul>
<li>GOOD (如果要使用后代选择器，适当地缩小层级，降低CSS权重)</li>
</ul>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="id">#nav</span> <span class="tag">a</span><span class="rules">{<span class="rule">…}</span></span>
</pre></td></tr></table></figure>

<h3 id="笔者认为…">笔者认为…</h3>
<p>笔者认为虽然ID是最高效的选择器，不过如果把所有要选择的元素全都写上ID也是一件很蠢的事…<br>ID选择器权重太高，不存在任何可重用性，因此要尽量少用ID选择器。<br>笔者倾向于使用类选择器，简短且语义化的命名，同时书写模块化的CSS会使你的CSS更容易扩展和可重用。</p>
<hr>
<p>参考文献：<br><a href="http://www.w3cplus.com/css/css-selector-performance" target="_blank">[1] CSS选择器的优化</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Writing_efficient_CSS" target="_blank">[2] Writing efficient CSS</a><br><a href="http://css-tricks.com/efficiently-rendering-css/" target="_blank">[3] Efficiently Rendering CSS</a><br><a href="http://www.alloyteam.com/2012/10/high-performance-css/" target="_blank">[4] 高性能CSS</a><br><a href="http://www.w3cplus.com/css/css-specificity-things-you-should-know.html" target="_blank">[5] 你应该知道的一些事情——CSS权重</a></p>
]]></content>
    
    
      <category term="CSS" scheme="http://snailsky.me/tags/CSS/"/>
    
      <category term="性能优化" scheme="http://snailsky.me/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="选择器" scheme="http://snailsky.me/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CSS" scheme="http://snailsky.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grunt的配置及liveReload功能实例]]></title>
    <link href="http://snailsky.me/2014/07/19/grunt%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>http://snailsky.me/2014/07/19/grunt的配置及使用示例/</id>
    <published>2014-07-19T11:27:42.000Z</published>
    <updated>2014-08-24T11:21:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Grunt的介绍">Grunt的介绍</h2>
<p>Grunt是一个自动化的项目构建工具，配置好Grunt可以完成压缩，代码检查，单元测试等任务。C/C++有makefile，Java有Maven，Nodejs有grunt~</p>
<p>Grunt常用的插件有：<br>1).grunt-contrib-uglify：压缩js代码<br>2).grunt-contrib-concat：合并js文件<br>3).grunt-contrib-qunit：单元测试<br>4).grunt-contrib-jshint：js代码检查<br>5).grunt-contrib-watch：文件监控</p>
<p>关于这些插件的使用 <a href="http://blog.fens.me/nodejs-grunt-intro/" target="_blank">grunt让Nodejs规范起来</a> 这篇文章已经做了详细的介绍，此就不多说了。</p>
<h2 id="完整实例">完整实例</h2>
<p>此实例完成的工作为：保存代码后网页自动刷新，即时查看代码效果</p>
<p>安装 grunt-cli(先保证nodejs安装完成)<br><img src="/img/gruntConfig/1.png" alt="grunt"><br>grunt-cli 安装完成<br><img src="/img/gruntConfig/2.png" alt="grunt"></p>
<p>全局安装grunt<br><img src="/img/gruntConfig/3.png" alt="grunt"></p>
<p>grunt安装完成<br><img src="/img/gruntConfig/4.png" alt="grunt"></p>
<p>安装grunt到本项目中<br><img src="/img/gruntConfig/6.png" alt="grunt"></p>
<p>安装完毕<br><img src="/img/gruntConfig/7.png" alt="grunt"></p>
<p>—save-dev自动将依赖写入了package.json</p>
<p>执行grunt 发现报错了<br><img src="/img/gruntConfig/8.png" alt="grunt"></p>
<p>原来是缺少gruntfile.js</p>
<p>创建gruntfile.js<br>(此处是livereload功能的示例，需下载这个chrome扩展程序，配合使用，功能：可以保存代码后网页自动刷新，即时查看代码效果）</p>
<p><img src="/img/gruntConfig/9.png" alt="grunt"></p>
<p>gruntfile.js 内容：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>module.exports = <span class="function"><span class="keyword">function</span><span class="params">(grunt)</span> {</span>
 <span class="comment">// 项目配置(任务配置)</span>
 grunt.initConfig({
                   pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),
                   watch: {
                    client: {
                     files: [<span class="string">'public/**/**/*'</span>, <span class="string">'public/*'</span>,<span class="string">'public/**/*'</span>,<span class="string">'views/*'</span>],
                     options: {
                      livereload: <span class="literal">true</span>
                     }
                    }
                   }
                  });
 <span class="comment">// 加载插件</span>
 grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);
 <span class="comment">// 自定义任务 即需执行： grunt live</span>
 grunt.registerTask(<span class="string">'live'</span>, [<span class="string">'watch'</span>]);
};
</pre></td></tr></table></figure>


<p>再次执行 又报错了<br><img src="/img/gruntConfig/10.png" alt="grunt"></p>
<p>是没找到grunt-contrib-watch 这个包</p>
<p>下载这个包<br><img src="/img/gruntConfig/11.png" alt="grunt"></p>
<p>下载完成<br><img src="/img/gruntConfig/12.png" alt="grunt"></p>
<p>再次执行grunt<br><img src="/img/gruntConfig/13.png" alt="grunt"></p>
<p>我们回来看下代码，发现 default 任务没有注册 ，<br>而我们自定义了live任务：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>grunt.registerTask(<span class="string">'live'</span>, [<span class="string">'watch'</span>]);
</pre></td></tr></table></figure>

<p>你现在可以执行 grunt live 来执行这个任务<br><img src="/img/gruntConfig/15.png" alt="grunt"></p>
<p>你也可以创建一个default任务<br>如果创建default 这样创建 添加到gruntfile里</p>
<p><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// Default task(s).</span>
grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'watch'</span>]);
</pre></td></tr></table></figure><br>此时你可以 输入命令 grunt 或 grunt watch 来执行这个任务<br><img src="/img/gruntConfig/14.png" alt="grunt"></p>
<p>至此 启动你下载好的chrome livereload那个插件即可。<br>此时你就可以实时看代码效果，代码保存网页那边就刷新了，妈妈再也不用担心我玩命的按F5啦 ╮(╯▽╰)╭</p>
]]></content>
    
    
      <category term="grunt" scheme="http://snailsky.me/tags/grunt/"/>
    
      <category term="nodejs" scheme="http://snailsky.me/tags/nodejs/"/>
    
      <category term="安装" scheme="http://snailsky.me/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="实践笔记" scheme="http://snailsky.me/categories/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 学习笔记 - 模块化编程]]></title>
    <link href="http://snailsky.me/2014/07/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    <id>http://snailsky.me/2014/07/12/JavaScript学习笔记 - 模块化编程/</id>
    <published>2014-07-12T03:05:46.000Z</published>
    <updated>2014-08-24T11:21:12.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间，我急需这种模块化的方法来管理我的JavaScript代码<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">Javascript模块化编程</a>这一系列文章给我很大帮助，介绍得很通俗易懂，小伙伴们可以看看，我将在此文基础上记录一些我的笔记。</p>
<hr>
<h2 id="JavaScript模块简介">JavaScript模块简介</h2>
<p>JavaScript不是一种模块化编程语言，它不支持“类”（class），更不用说“模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用。）</p>
<p>我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。通过使用函数产生模块，我们几乎可以完全摒弃全局变量的使用，从而缓解这个JavaScript的最为糟糕的特性之一所带来的影响。</p>
<h2 id="JavaScript模块写法">JavaScript模块写法</h2>
<h3 id="立即执行函数">立即执行函数</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">0</span>;
    <span class="keyword">var</span> setCount = <span class="function"><span class="keyword">function</span><span class="params">(start)</span>{</span>
        count=start;
    }
    <span class="keyword">var</span> getCount = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> count;
    }
    <span class="keyword">return</span> {
        setCount:setCount,
        getCount:getCount,
    }
})();
</pre></td></tr></table></figure>

<p>本例是JavaScript模块的基本写法。使用到了<a href="http://snailsky.me/2014/07/11/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89/" target="_blank">闭包</a>。</p>
<p>此时外部代码无法读取内部的count变量。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(foo.count);   <span class="comment">//undefined</span>
</pre></td></tr></table></figure>

<h3 id="导入全局变量">导入全局变量</h3>
<p>把全局变量作为参数传递给一个立即执行函数，这样就完成了全局变量的导入，立即执行函数中可以使用此全局变量的方法，并可以修改（简化）全局变量的名称</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="list">(<span class="title">function</span> <span class="list">(<span class="title">$</span>, YAHOO)</span> <span class="collection">{
	// now have access to globals jQuery <span class="list">(<span class="title">as</span> $)</span> and YAHOO in this code
}</span><span class="list">(<span class="title">jQuery</span>, YAHOO)</span>)</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<h3 id="导出模块">导出模块</h3>
<p>通过在立即执行函数中返回一个Object，将模块导出到全局空间供其他模块使用</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> mod = {},
		privateVariable = <span class="number">1</span>;
	<span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span><span class="params">()</span> {</span>
		console.log(<span class="string">"this is a private method"</span>);
	}
	mod.moduleProperty = <span class="number">2</span>;
	mod.moduleMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		console.log(privateVariable);       
	};
    mod.callPrivateMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        privateMethod();
    }
	<span class="keyword">return</span> mod;
}());

<span class="comment">//test</span>
foo.moduleMethod(); <span class="comment">//output：1</span>
console.log(foo.moduleProperty);  <span class="comment">//output：2</span>
foo.callPrivateMethod(); <span class="comment">//output："this is a private method"</span>
foo.privateMethod(); <span class="comment">//undefined</span>
console.log(foo.privateVariable); <span class="comment">//undefined</span>
</pre></td></tr></table></figure>

<h3 id="方法的重写">方法的重写</h3>
<p>在“导出模块”例子基础上，重写他的moduleMethod方法..</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="params">(mod)</span> {</span>
	<span class="keyword">var</span> old_moduleMethod = mod.moduleMethod;
	mod.moduleMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		<span class="comment">// method override, has access to old through old_moduleMethod...</span>
        console.log(<span class="string">"this is already overridden"</span>);
	};
	<span class="keyword">return</span> mod;
}(foo));

<span class="comment">//test</span>
foo.moduleMethod(); <span class="comment">//output："this is already overridden"</span>
</pre></td></tr></table></figure>

<p>并且你可以在新方法中访问老方法，如果需要的话。</p>
<h3 id="克隆并重写方法">克隆并重写方法</h3>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> cfoo = (<span class="function"><span class="keyword">function</span><span class="params">(old)</span>{</span>
    <span class="keyword">var</span> mod = {},
		key;
	<span class="keyword">for</span> (key <span class="keyword">in</span> old) {
		<span class="keyword">if</span> (old.hasOwnProperty(key)) {
			mod[key] = old[key];
		}
	}
	<span class="keyword">var</span> super_moduleMethod = old.moduleMethod;
	mod.moduleMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		<span class="comment">// override method on the clone, access to super through super_moduleMethod</span>
        console.log(<span class="string">"this is a override method on the clone"</span>);
	};
	<span class="keyword">return</span> mod;
})(foo);

<span class="comment">//test</span>
foo.moduleMethod(); <span class="comment">//output：1</span>
cfoo.moduleMethod(); <span class="comment">//output："this is a override method on the clone"</span>
cfoo.callPrivateMethod(); <span class="comment">//output："this is a private method"</span>
</pre></td></tr></table></figure>

<p>此可以克隆某个模块并可根据自己需要重写其方法。</p>
<h3 id="模块的继承">模块的继承</h3>
<p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块。在”立即执行函数”例子的基础上，继承bar。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span><span class="params">(mod)</span>{</span>
    mod.newFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"this is a new function"</span>);
    }
    <span class="keyword">return</span> mod;
})(bar);

<span class="comment">//test</span>
console.log(bar.getCount()); <span class="comment">//output：0</span>
bar.setCount(<span class="number">4</span>);
console.log(bar.getCount()); <span class="comment">//output：4</span>
bar.newFunc(); <span class="comment">//output："this is a new function"</span>
</pre></td></tr></table></figure>

<p>我们看到可以访问foo中的老函数和新方法。那他可不可以访问foo中的私有变量呢？</p>
<p>let’s have a try…</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span><span class="params">(mod)</span>{</span>
    mod.newFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"this is a new function"</span>);
    }
    mod.testFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(count);
        console.log(<span class="keyword">this</span>.count);
    }
    <span class="keyword">return</span> mod;
})(bar);

<span class="comment">//test</span>
bar.testFunc(); <span class="comment">//两种访问count方式，结果都是undefined，即说明这种方法访问不到父模块的私有变量</span>
</pre></td></tr></table></figure>

<p><em>注意</em>：这种方法是访问不到父模块的私有变量的。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象。可以用一下方式解决：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span><span class="params">(mod)</span>{</span>
    mod.newFunc=<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"this is a new function"</span>);
    }
    <span class="keyword">return</span> mod;
})(bar||{});
</pre></td></tr></table></figure>

<h2 id="模块应用-单例模式">模块应用-单例模式</h2>
<p>模块模式通常结合单例模式（Singleton Pattern）使用。JavaScript的单例就是用对象字面量表示法创建的对象，对象的属性值可以试数值或函数，并且属性值在该对象的生命周期中不会发生变化。</p>
<p>单例的最佳实践：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> Universe;
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>    
    <span class="keyword">var</span> instance;   
    Universe = <span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span> {</span>        
        <span class="keyword">if</span> (instance) {
            <span class="keyword">return</span> instance;
        }        
        instance = <span class="keyword">this</span>;        
        <span class="comment">// all the functionality</span>
        <span class="keyword">this</span>.start_time = <span class="number">0</span>;
        <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;
    };
}());
</pre></td></tr></table></figure>

<p>测试一下一以上代码：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">// testing</span>
<span class="built_in">var</span> uni <span class="subst">=</span> <span class="literal">new</span> Universe();
<span class="built_in">var</span> uni2 <span class="subst">=</span> <span class="literal">new</span> Universe();
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="subst">===</span>uni2); <span class="comment">//output：true</span>

<span class="comment">// adding to the prototype</span>
Universe<span class="built_in">.</span>prototype<span class="built_in">.</span>nothing <span class="subst">=</span> <span class="literal">true</span>;

<span class="built_in">var</span> uni <span class="subst">=</span> <span class="literal">new</span> Universe();

<span class="comment">// again adding to the prototype</span>
<span class="comment">// after the initial object is created</span>
Universe<span class="built_in">.</span>prototype<span class="built_in">.</span>everything <span class="subst">=</span> <span class="literal">true</span>;

<span class="built_in">var</span> uni2 <span class="subst">=</span> <span class="literal">new</span> Universe();

<span class="comment">// linked to the objects</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>nothing); <span class="comment">// output：true</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni2<span class="built_in">.</span>nothing); <span class="comment">// output：true</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>everything); <span class="comment">// output：true</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni2<span class="built_in">.</span>everything); <span class="comment">// output：true</span>

console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>constructor<span class="built_in">.</span>name); <span class="comment">// output："Universe"</span>
console<span class="built_in">.</span><span class="keyword">log</span>(uni<span class="built_in">.</span>constructor <span class="subst">===</span> Universe); <span class="comment">// output："Universe"</span>
</pre></td></tr></table></figure>

<p>我们发现new出来的两个Universe对象是同一个所以他们是同一个对象，实现了单例，且加进原型的属性在两个对象均可访问。</p>
<p>关于constructor：<br>constructor属性不影响任何JavaScript的内部属性。instanceof检测对象的原型链，通常你是无法修改的（不过某些引擎通过私有的<strong>proto</strong>属性暴露出来）。</p>
<p>constructor其实没有什么用处，只是JavaScript语言设计的历史遗留物。由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。不过，从编程习惯上，我们应该尽量让对象的constructor指向其构造函数，以维持这个惯例。</p>
<h2 id="模块的规范">模块的规范</h2>
<p>目前，通行的Javascript模块规范有：CommonJS（node.js应用此规范），AMD(异步模块定义)，CMD（通用模块定义）。<br>主要有两个Javascript库实现了AMD规范：require.js和curl.js。<br>实现了CMD规范：sea.js。</p>
<p>关于这些库和规范的讨论相关文章有：<br><a href="https://github.com/seajs/seajs/issues/277" target="_blank">seaJS与RequireJS的异同</a><br><a href="http://www.zhihu.com/question/20351507/answer/14859415" target="_blank">AMD 和 CMD 的区别有哪些？</a></p>
<p>先写到这，对于这些库，尚在了解中。等应用一阵再写相关的博文吧。</p>
<hr>
<p>参考文献：<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">[1] Javascript模块化编程</a><br><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank">[2] JavaScript Module Pattern: In-Depth</a><br><a href="http://book.douban.com/subject/2994925/" target="_blank">[3] JavaScript - The Good Parts</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/02/20/2352817.html" target="_blank">[4] 深入理解JavaScript系列（25）：设计模式之单例模式</a><br><a href="https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/singleton.html" target="_blank">[5] javascript-patterns  singleton</a></p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 学习笔记 - 闭包（closure）]]></title>
    <link href="http://snailsky.me/2014/07/11/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89/"/>
    <id>http://snailsky.me/2014/07/11/JavaScript学习笔记 - 闭包（closure）/</id>
    <published>2014-07-11T12:59:40.000Z</published>
    <updated>2014-08-24T11:21:12.000Z</updated>
    <content type="html"><![CDATA[<p>本文本着3个目的进行探究<br>1.闭包是什么<br>2.为什么要用闭包<br>3.闭包的应用场景<br>我的傻瓜式学习笔记，给自己备忘，也希望能帮助到一些人，如有错误欢迎指正。O(∩_∩)O~</p>
<hr>
<h2 id="为什么要用闭包？">为什么要用闭包？</h2>
<h3 id="作用域">作用域</h3>
<p>函数是JavaScript中唯一拥有自身作用域的结构。（JavaScript不支持块级作用域）<br>意味着定义在函数中的参数和变量在函数外部是不可见的，而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见。</p>
<p>一个值得注意的例子：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> a = <span class="number">3</span>,b = <span class="number">5</span>;
    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">var</span> b = <span class="number">7</span>,c = <span class="number">11</span>;
        <span class="comment">//此时，a为3，b为7，c为11。</span>
        a += b+c;
        <span class="comment">//此时，a为21，b为7，c为11。</span>
    };
    <span class="comment">//此时，a为3，b为5，而c还没有定义</span>
    bar();
    <span class="comment">//此时，a为21，b为5</span>
};
</pre></td></tr></table></figure>

<h4 id="函数访问全局变量">函数访问全局变量</h4>
<p>JavaScript中函数内部可以直接访问全局变量。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> n=<span class="number">999</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    console.log(n);
}

<span class="comment">//test</span>
f1(); <span class="comment">// 999</span>
</pre></td></tr></table></figure>

<p>函数外部无法读取函数内的局部变量。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> n=<span class="number">999</span>;
}

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> n=<span class="number">999</span>;
}
f1();

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<p><em>注意</em>：此时的n，如果声明时没有用var命令，在执行了声明它的函数后，事实上是产生了一个全局变量！</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span>{</span>
    n=<span class="number">999</span>;
}

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> m=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">{
    n=999;
}</span>
<span class="title">f1</span><span class="params">()</span>;</span>

<span class="comment">//test</span>
console.log(m);    <span class="comment">// output：123</span>
console.log(n);    <span class="comment">// output：999</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> n=<span class="number">123</span>;
<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">{
    n=999;
}</span>
<span class="title">f1</span><span class="params">()</span>;</span>

<span class="comment">//test</span>
console.log(n);    <span class="comment">// output：999</span>
</pre></td></tr></table></figure>

<h4 id="外部访问函数局部变量">外部访问函数局部变量</h4>
<p>正常情况下JavaScript无法获得函数内部的局部变量的值，可是我们有时需要获取，我们应该怎样做？</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
        console.log(count);
    }
}

<span class="comment">//test</span>
counter();  <span class="comment">//木有反应</span>
</pre></td></tr></table></figure>

<p>以上代码木有反应，因为我们执行了counter函数却没执行counter函数里面的个体函数哟..<br>我们在counter里面调用一下get();这样执行counter函数即执行了get函数。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
        console.log(count);
    }
    <span class="keyword">get</span>();
}

<span class="comment">//test</span>
counter();  <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>这样我们便访问到了counter的局部变量，哈哈，大功告成！…了吗？<br>我们这样做和一下代码有什么区别？！</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    console.log(count);
}

<span class="comment">//test</span>
counter();  <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>这样做行不通，我们另寻他径。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> count;
    }
    <span class="keyword">return</span> <span class="keyword">get</span>;
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo());    <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>我们返回了一个函数名get，当执行了counter函数后返回了counter函数内的get函数的引用并赋值给foo，在外面执行了foo()相当于调用了get()，我们获取到了局部变量count！！！~</p>
<p>以下例子更加灵活</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">return</span> count;
        }
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo.<span class="keyword">get</span>());    <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>这次我们return了一个对象字面量，在执行counter函数后返回了一个对象字面量并赋给一个foo变量，里面有个名为get的key，其value为一个匿名函数（是否是匿名并没有关系）。我们执行字面量中的get方法，得到了count。</p>
<p>我们希望能在一个函数中访问局部变量，完成更多的事，不仅仅是这一个用途而已。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">return</span> count;
        },
        increment:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            count++;
        }
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：5</span>
foo.increment();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：6</span>
</pre></td></tr></table></figure>

<p>以上例子也可以这么写：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">5</span>;
     <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
          <span class="keyword">return</span> count;
     }
     <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
         count++;
     }
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="keyword">get</span>,
        increment:increment
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：5</span>
foo.increment();
console.log(foo.<span class="keyword">get</span>());    <span class="comment">//output：6</span>
</pre></td></tr></table></figure>

<p>再改进一下，使他更有意义：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">(start)</span>{</span>
    <span class="keyword">var</span> count=start;
     <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
          <span class="keyword">return</span> count;
     }
     <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
         count++;
     }
    <span class="keyword">return</span> {
        <span class="keyword">get</span>:<span class="keyword">get</span>,
        increment:increment
    }
}

<span class="comment">//test</span>
<span class="keyword">var</span> foo=counter(<span class="number">4</span>);
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：4</span>
foo.increment();
console.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>至此，我们已经应用到了闭包。<br>这个例子中的counter函数返回两个闭包，函数get和函数increment。这两个函数都维持着对外部作用域 counter 的引用，因此总可以访问此作用域内定义的变量 count。</p>
<p>以上例子，你还可以这样写</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    <span class="keyword">var</span> count=<span class="number">0</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">setCount</span><span class="params">(start)</span>{</span>
        count=start;
    }
     <span class="function"><span class="keyword">function</span> <span class="title">getCount</span><span class="params">()</span>{</span>
          <span class="keyword">return</span> count;
     }
     <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
         count++;
     }
    <span class="keyword">return</span> {
        setCount:setCount,
        getCount:getCount,
        increment:increment
    }
}());

<span class="comment">//test</span>
console.log(foo.getCount());   <span class="comment">//output：0</span>
foo.increment();
console.log(foo.getCount());   <span class="comment">//output：1</span>
<span class="comment">//重新设置count</span>
foo.setCount(<span class="number">4</span>);
console.log(foo.getCount());   <span class="comment">//output：4</span>
foo.increment();
console.log(foo.getCount());   <span class="comment">//output：5</span>
</pre></td></tr></table></figure>

<p>此处我们直接把调用函数后的结果赋值给foo，注意最后一行的()，成为立即执行函数。<br>之后我们可以直接使用foo.xx的方式来访问相关函数。<br>这也是JavaScript模块化编程的一种写法。</p>
<p>关于立即执行函数，以下两种写法均可，看个人习惯：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">//写法一</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">/* code */</span> } ());
<span class="comment">//写法二</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">/* code */</span> })();
</pre></td></tr></table></figure>

<p>(function(){}())是使用了强制运算符执行函数调用运算，(function(){})()是通过函数调用运算符操作函数引用。两者功能上是一致的，只是运算过程不同。</p>
<h2 id="闭包是什么？">闭包是什么？</h2>
<p>闭包是 JavaScript一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。 因为函数是JavaScript中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p>
<p><em>闭包在书中是这样被描述的</em>：</p>
<p>闭包是函数和执行它的作用域组成的综合体 — 《JavaScript权威指南》</p>
<p>闭包是一种在函数内访问和操作外部变量的方式;所有的函数都是闭包;函数可以访问它被创建时的上下文环境，成为闭包  — 《JavaScript语言精粹》</p>
<p>内部函数比它的外部函数具有更长的生命周期</p>
<p>更简单的定义 — 闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h3 id="改变私有变量？">改变私有变量？</h3>
<p>我们能否在闭包外面改变私有变量呢？</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">(start)</span>{</span>
   <span class="keyword">var</span> count=start;
    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span>{</span>
         <span class="keyword">return</span> count;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">()</span>{</span>
        count++;
    }
   <span class="keyword">return</span> {
       <span class="keyword">get</span>:<span class="keyword">get</span>,
       increment:increment
   }

ar foo=counter(<span class="number">4</span>);
oo.hack = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
   count = <span class="number">999</span>;
;

/test
onsole.log(foo.<span class="keyword">get</span>());   <span class="comment">//output：4</span>
</pre></td></tr></table></figure>

<p>这种做法，答案是NO。foo.hack没有定义在counter作用域内，以上代码不会改变定义在counter作用域中的count值。</p>
<h3 id="闭包的优点">闭包的优点</h3>
<ul>
<li>实现了私有变量</li>
<li>保护命名空间</li>
<li>避免污染全局变量</li>
</ul>
<h3 id="闭包的用途">闭包的用途</h3>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<h2 id="使用闭包的注意点">使用闭包的注意点</h2>
<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h3 id="循环中的闭包">循环中的闭包</h3>
<p>一个常见的错误，出现在循环中使用闭包，假设我们需要在每次循环中访问循环序号</p>
<h4 id="例一:"><em>例一:</em></h4>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(i);
    }, <span class="number">1000</span>);
}
</pre></td></tr></table></figure>

<p>执行结果为：<br><img src="/img/closure/1.jpg" alt="closure"></p>
<p>上面的代码不会输出数字 0 到 9，而是会输出数字 10 十次。</p>
<p>当 console.log 被调用的时候，匿名函数保持对外部变量 i 的引用，此时 for循环已经结束， i 的值被修改成了 10.</p>
<p>为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。</p>
<h4 id="避免引用错误">避免引用错误</h4>
<p>为了正确的获得循环序号，最好使用匿名包裹器。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    (<span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(e);
        }, <span class="number">1000</span>);
    })(i);
}
</pre></td></tr></table></figure>

<p>执行结果为：<br><img src="/img/closure/2.jpg" alt="closure"></p>
<p>外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 e 变量就拥有了 i 的一个拷贝。</p>
<p>当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。</p>
<p>有另一个方法完成同样的工作；那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    setTimeout((<span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(e);
        }
    })(i), <span class="number">1000</span>)
}
</pre></td></tr></table></figure>

<p>执行结果为：<br><img src="/img/closure/3.jpg" alt="closure"></p>
<h4 id="例二:"><em>例二:</em></h4>
<p>糟糕的例子：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>var foo=<span class="function"><span class="keyword">function</span><span class="params">(nodes)</span>{</span>
    var <span class="built_in">i</span>;
    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;<span class="transposed_variable">nodes.</span><span class="built_in">length</span>; <span class="built_in">i</span>+=<span class="number">1</span>)<span class="cell">{
        node[i].onclick=function(e){
            console.log(i);
        }</span>;
    }
};
</pre></td></tr></table></figure>

<p>错误来源于在循环中创建函数，其本意是想传递给每个事件处理器一个唯一值(i)。但它未能达到目的，因为事件处理器函数绑定了变量i本身，而不是<br>函数在构造时的变量i的值。</p>
<h4 id="避免引用错误-1">避免引用错误</h4>
<p>例一的解法：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span><span class="params">(nodes)</span>{</span>
    <span class="keyword">var</span> i;
    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;nodes.length; i+=<span class="number">1</span>){
        (<span class="function"><span class="keyword">function</span><span class="params">(n)</span>{</span>
           node[n].onclick=<span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
                       console.log(n);
           };
        })(i);
    }
};
</pre></td></tr></table></figure>

<p>或者你可以这样做，创建一个辅助函数：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>var foo=<span class="function"><span class="keyword">function</span><span class="params">(nodes)</span>{</span>
    var helper=<span class="function"><span class="keyword">function</span><span class="params">(i)</span>{</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
           <span class="transposed_variable">console.</span><span class="built_in">log</span>(<span class="built_in">i</span>);
        };
    };
    var <span class="built_in">i</span>;
    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;<span class="transposed_variable">nodes.</span><span class="built_in">length</span>; <span class="built_in">i</span>+=<span class="number">1</span>)<span class="cell">{
        node[i].onclick=helper(i);
    }</span>
};
</pre></td></tr></table></figure>

<p><em>避免在循环中创建函数</em>，在循环中创建函数，会导致错误，只会带来无谓的计算及引起混淆。<br>在循环之外创建一个辅助函数，让这个辅助函数再返回一个绑定了当前i值的函数，这样就不会导致混淆了。</p>
<hr>
<p>参考文献：<br><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank">[1] 学习Javascript闭包（Closure）</a><br><a href="http://book.douban.com/subject/2994925/" target="_blank">[2] JavaScript - The Good Parts</a><br><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.closures" target="_blank">[3] JavaScript 秘密花园 - 闭包和引用</a><br><a href="http://www.slideshare.net/lijing00333/javascript-12526041" target="_blank">[4] 潜力无限的编程语言JavaScript</a></p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[致将与前端技术渡过的宝贵假期]]></title>
    <link href="http://snailsky.me/2014/07/04/%E8%87%B4%E5%B0%86%E4%B8%8E%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%B8%A1%E8%BF%87%E7%9A%84%E5%AE%9D%E8%B4%B5%E5%81%87%E6%9C%9F/"/>
    <id>http://snailsky.me/2014/07/04/致将与前端技术渡过的宝贵假期/</id>
    <published>2014-07-04T03:04:13.000Z</published>
    <updated>2014-07-04T04:54:30.000Z</updated>
    <content type="html"><![CDATA[<p>今天心血来潮，在家呆着，怕自己没了激情，自己给自己鼓励一下  (╯▔▽▔)╯</p>
<p>　　博主是个宅女懒人，从小就是，放假从来都是一觉睡到大中午，下午昏昏沉沉的看电视到晚上，接着睡…啊 天…现在觉得过去的自己真是好口怕…</p>
<p>　　恐怕只有自己喜欢的事才肯花时间，并孜孜不倦…</p>
<p>　　比如说喜欢周笔畅这件事,10年了都…并且基本上她出席的所有节目都看过，所有专辑歌曲包括各种场合及节目中翻唱过的歌都会唱(“▔□▔)/(“▔□▔)/(“▔□▔)/再比如说曾经因为很喜欢一首歌里面的伴奏乐器的声音(那个乐器叫做ukulele，是个可爱的长得像小小的吉他的乐器)特意较深入地去了解这个乐器,后来一个哥哥买了，借给我玩，我还辛辛苦苦去网上扒琴谱，把这首歌弹会了…再比如说动漫，海贼王600多集我可一集没拉哦…等等..我貌似说的都是玩的  Σ(￣。￣ﾉ)ﾉ．．．是的，博主是个很爱玩的女汉纸…所以说经过20多年的观察，偶发现自己必须要从事一件自己喜欢的工作以此为乐才能做得好，而不想只是混口饭吃…</p>
<p>　　上课学习编程，老师讲课总是忍不住走神，如果是自己写代码倒是来了精神。自己写代码总是感觉干听着好玩多了…可是在用JAVA写增删改查，用JAVA框架SSH写增删改查，用EJB写增删改查之后，博主终于要吐了…博主开始觉得之前用C语言写ACM的题目时候真有趣…开始想念自己刚刚自学js那会儿写的俄罗斯方块的日子，每天都充满了期待。</p>
<p>　　这里只是自己的感受，不是说哪门语言好哪门语言不好，我相信不管用哪门语言写自己喜欢的东西不会觉得烦会觉得很有趣，而我也相信不管你用哪门语言无休止的狂写增删改查之后，也会想吐的…我从作业里面感到厌烦，我希望能自己开动脑筋做些有趣的东西，比如学JAVA为什么一定要做个系统，增删改查？我也可以自己做一个基于JAVA的小游戏，不过上课嘛随便做做就好，没有那些闲工夫，因为我还有实验室的工作。即使这样，苦中求乐，我还每次做系统都给自己一些挑战，比如说忍受不了丑丑的页面，花时间把它设计的好看些，再自己加个上传图片的功能，不用老师教的方法生成图表，用前端的画图表的库之类的。这样每次做的不光是增删改查，还有其他挑战，每次做了都感觉自己有所提升也就感觉上了这课自己没有浪费时间。</p>
<p>　　而js能实现各种酷炫的效果，让我很迷醉，虽然说js适应各种不同浏览器可能写法都不一样，这点真的有点恶心，不如说是IE恶心比较好？博主也懒得去理IE，劳资更喜欢移动web，因为不用去考虑那些个奇奇怪怪的事情。所以至今IE的兼容方面也没有什么研究(主啊，原谅我吧)，也许在需要的时候才去研究是最好的时机，反正我现在觉得研究那个是浪费时间。做组件的时候我仍然觉得js很好玩，虽然那时候自己写出的代码真的丑。</p>
<p>　　再后来认识了node.js我感觉我的天空一下子放亮了。从那之后开始也陆陆续续地接触到了新鲜的技术，喜欢新技术，很有趣。后来开始写node 和angular，开始使用grunt 感觉这些东西比JAVA那套东西要可爱得多。而且之前从来没有想过以后要从事什么职位，在那之后我想成为一名前端攻城狮…并想为了这个目标努力奋斗。</p>
<p>　　我认为”想”比什么都重要。</p>
<p>　　我的基础并不扎实，不管什么语言，我都不喜欢看书学，感觉很无聊，我就喜欢自己敲，管他对不对，遇到问题了就上网搜一下，这种狂放的学习方法很是符合我的性格O__O” 。但是既然想成为专业的人士肯定基础要牢一些才行，所以这个假期最主要的目标是多做东西，多补基础，我希望边学边在博客上写笔记，那是极好的，这样大概能督促我认真一点。做东西时也注意记录遇到的问题之类的，以前遇到那些问题由于自己没有记笔记的习惯，所以很可惜…没有记下你们…今后我会注意的~如果能做很多自己喜欢的东西出来是极好的。不要浪费时间才好。有时间还可以研究自己以前很好奇但是没用过的东西。希望有这个时间。</p>
<p>　　因为当初的喜欢，现在要付出加倍努力，成为优秀的码农= =　希望自己可以做到~从今天起到假期结束，我希望每天都可以看到充充实实的小！绿！点！You Can Do It ！！！ 加油！</p>
]]></content>
    
    
      <category term="感悟" scheme="http://snailsky.me/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="心情" scheme="http://snailsky.me/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="日记" scheme="http://snailsky.me/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="学习生活" scheme="http://snailsky.me/tags/%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    
      <category term="生活随笔" scheme="http://snailsky.me/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB的安装及简单使用示例]]></title>
    <link href="http://snailsky.me/2014/07/02/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>http://snailsky.me/2014/07/02/mongodb的安装及简单使用示例/</id>
    <published>2014-07-02T06:26:23.000Z</published>
    <updated>2014-07-02T09:34:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是MongoDB">什么是MongoDB</h2>
<p>MongoDB是介于传统数据库和NoSQL数据库之间的一种非关系型数据库。MongoDB使用c++实现，具有高可靠，高可用等优秀特性。<br>Mongo的官方网站地址是：<a href="http://www.mongodb.org/" target="_blank">http://www.mongodb.org/</a></p>
<h2 id="MongoDB的安装(windows下)">MongoDB的安装(windows下)</h2>
<p>在官方网站下载了MongoDB了之后，我们就可以进行MongoDB的安装工作了。<br>（以下截图来自在windows server 2003系统上面安装mongo过程中）</p>
<h3 id="1-安装包解压">1.安装包解压</h3>
<p>将mongo安装包解压放在D:/ 改名为mongodb<br><img src="/img/mongoInstall/mongodb1_1.png" alt="mongo的安装"></p>
<h3 id="2-新建存数据的文件夹">2.新建存数据的文件夹</h3>
<p>mongodb下新建文件夹db（随便叫什么都行）用来存mongo的数据<br><img src="/img/mongoInstall/mongodb1_2.png" alt="mongo的安装"></p>
<h3 id="3-运行mongo">3.运行mongo</h3>
<p>现在你已经可以运行mongo咯~<br><em>方法一</em><br>mongodb的bin目录下，shift+鼠标右键&gt;在此处打开命令窗口&gt;输入以下命令</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>mongod --dbpath D:<span class="command">\Mongodb</span><span class="command">\db</span>
</pre></td></tr></table></figure>

<p>这样就可以启动mongo了~</p>
<p><em>方法二</em><br>不过由于作者我是个懒虫，所以为了每次少输入这么个命令，所以就写了个bat文件，O(∩_∩)O哈哈~<br>在mongodb的bin文件夹下新建一个”快速启动.bat”<br><img src="/img/mongoInstall/mongodb1_3.png" alt="mongo的安装"><br>bat文件内容如下<br><img src="/img/mongoInstall/mongodb1_4.png" alt="mongo的安装"><br>保存，并双击”快速启动.bat”将看到以下界面，运行成功~<br><img src="/img/mongoInstall/mongodb1_5.png" alt="mongo的安装"><br>在浏览器输入：<a href="http://localhost:27017/" target="_blank">http://localhost:27017/</a><br>可以看到如下提示：<br>You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number</p>
<p>如此，MongoDB数据库服务已经成功启动了。</p>
<h2 id="MongoDB简单使用示例">MongoDB简单使用示例</h2>
<p>这里只做最简单的示范，如果有兴趣详细了解可以去看《MongoDB权威指南》这本书哟~</p>
<p>博主偶数据方面都偏爱使用可视化工具,使用起较方便( 其实是因为懒吧Σ(￣。￣ﾉ)ﾉ ),MongoDB我是用的可视化工具是Robomongo…</p>
<h3 id="创建新的database">创建新的database</h3>
<p>在你的connection（左上角可新建connection）上右键&gt;单击CreateDatabase&gt;输入数据库名字&gt;create 这样就创建完成了..<br>像这样：<br><img src="/img/mongoInstall/mongodb1_6.jpg" alt="robomongo的使用"><br>新建的数据库里啥都没有,首先偶们先来给他添一张表吧,右键数据库&gt;Open Shell 在右边框框里可输入命令</p>
<h3 id="创建新表">创建新表</h3>
<p>现在我们创建一张用户表users（包含字段“用户名”、“密码”、“注册时间”）,我们可以这样写</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">db</span><span class="class">.users</span><span class="class">.save</span>(<span class="rules">{
                     <span class="rule"><span class="attribute">username</span>:<span class="value"><span class="string">'admin'</span> ,
                     password:<span class="string">'admin'</span>,
                     register_time : new <span class="function">Date()</span>,
              </span></span></span>})
</pre></td></tr></table></figure>

<p>现在我们点击红框框里的执行按钮,运行我们刚刚写的代码<br><img src="/img/mongoInstall/mongodb1_7.jpg" alt="robomongo的使用"></p>
<h3 id="查询">查询</h3>
<p>执行成功后我们发现左边collections下多出一张users表,此时我们执行代码来查询一下users表中都有神马<br>以下命令将查询出users中所有数据：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.find</span>()
</pre></td></tr></table></figure>

<p>我们看到刚才插入的数据确实已经在这张users表中了<br><img src="/img/mongoInstall/mongodb1_8.jpg" alt="robomongo的使用"></p>
<h3 id="更新">更新</h3>
<p>我们尝试把刚刚插入的那个用户的密码改成123456</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.update</span>(
    { <span class="string">"username"</span>: <span class="string">"admin"</span> },
    { <span class="string">"$set"</span>: { <span class="string">"password"</span>: <span class="string">"123456"</span> } }
)
</pre></td></tr></table></figure>

<p>之后查询一下<br><img src="/img/mongoInstall/mongodb1_9.jpg" alt="robomongo的使用"><br>我们发现密码字段已经变成了123456</p>
<h3 id="插入">插入</h3>
<p>我们尝试插入一条新数据</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">db</span><span class="class">.users</span><span class="class">.insert</span>(<span class="rules">{
                     <span class="rule"><span class="attribute">username</span>:<span class="value"><span class="string">'test'</span> ,
                     password:<span class="string">'test'</span>,
                     register_time : new <span class="function">Date()</span>
              </span></span></span>})
</pre></td></tr></table></figure>

<p>第一次执行成功，我们不小心执行了两次！<br>查询一下，也许我们只希望出现一个叫做test的用户，可是现在数据库中有两个了！<br><img src="/img/mongoInstall/mongodb1_11.jpg" alt="robomongo的使用"></p>
<p>我们想保证文档的”username”键都有不一样的值，创建唯一索引可以确保集合的每一个文档的指定值都有唯一值。</p>
<h3 id="唯一索引">唯一索引</h3>
<p>我们先把重复创建的名叫test的用户删除（只保留了一个test用户），再来执行下面代码创建唯一索引：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.ensureIndex</span>({<span class="string">"username"</span>:<span class="number">1</span>},{<span class="string">"unique"</span>:true})
</pre></td></tr></table></figure>

<p>创建成功后，我们再执行上面插入名叫test的用户（此时已经有一个叫test的用户在数据库中）<br><img src="/img/mongoInstall/mongodb1_12.jpg" alt="robomongo的使用"><br>我们发现报错了！test用户插入不进去，因为唯一索引起了作用，用find查询，也并没有改变，我们的唯一索引创建成功~</p>
<h3 id="删除">删除</h3>
<p>我们再尝试将admin这个user删除掉(注意：这里是筛选条件的删除)</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db.users.remove({<span class="string">'username'</span>:<span class="string">'admin'</span>})
</pre></td></tr></table></figure>

<p>之后查询下<br><img src="/img/mongoInstall/mongodb1_13.jpg" alt="robomongo的使用"><br>我们发现现在admin这个用户已经被删除，只剩下了test用户…</p>
<p><em>注意</em>：remove操作较危险,要小心给其传递条件,如果不加条件,像这样:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>db<span class="preprocessor">.users</span><span class="preprocessor">.remove</span>()
</pre></td></tr></table></figure>

<p>运行该命令后会移除users数据库中所有的数据,需谨慎使用！</p>
<p>目前为止,是基础中的基础,很简单对不对？不过实际应用中会比上述例子要复杂得多。</p>
<h3 id="在Node-js中使用MongoDB">在Node.js中使用MongoDB</h3>
<p>使用mongoose类库，可以让JSON数据直接入库MongoDB。这里并不做过多介绍,有兴趣,或需要用到的朋友可以去了解下。<br>mongoose官网：<a href="http://mongoosejs.com/" target="_blank">http://mongoosejs.com/</a></p>
<h4 id="一些问题">一些问题</h4>
<p>以下记录一点,我遇到的问题,其实并不难,但是如果要去找就很花时间。</p>
<p>有一张表，表结构如下(此为缩略版本的mongoose的表结构)：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> VersionSchema = <span class="keyword">new</span> Schema({
	                            username:{ type:<span class="built_in">String</span>, index: <span class="literal">true</span> } ,
	                            historyVersion:
		                            [
			                            {
			                                version:<span class="built_in">String</span>,
				                            time : { type: <span class="built_in">Date</span>, <span class="keyword">default</span>: <span class="built_in">Date</span>.now },
				                            describe:<span class="built_in">String</span>
			                            }
		                            ]
                            });
<span class="keyword">var</span> Version = mongodb.mongoose.model(<span class="string">"Version"</span>, VersionSchema);
</pre></td></tr></table></figure>

<p>historyVersion是一个数组，数组里面存放的是对象类型。</p>
<ul>
<li>关于覆盖一个表中类型为数组中的某个对象的某个字段 = =<br>我要改historyVersion这个数组的某个对象的某个字段的值。<br>做法如下：<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db.versions.update(
    { <span class="string">"username"</span>: <span class="string">"admin"</span>,<span class="string">'historyVersion._id'</span>:ObjectId(<span class="string">"539db613ec7788dc2414cacf"</span>) },
    { <span class="string">"<span class="variable">$set</span>"</span>: { <span class="string">"historyVersion.$.version"</span>: <span class="string">"2"</span> } }
)
</pre></td></tr></table></figure>

</li>
</ul>
<p>historyVersion中对象中的_id是自动生成的，通过这个来辨别更新哪个对象里的字段</p>
<ul>
<li>关于删除一个表中类型为数组中的某个对象<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db.versions.update(
    {<span class="string">'username'</span><span class="symbol">:<span class="string">'test'</span></span>},
    {<span class="variable">$pull</span><span class="symbol">:</span>{<span class="string">'historyVersion'</span><span class="symbol">:</span>{<span class="string">'_id'</span><span class="symbol">:ObjectId</span>(<span class="string">"539dcd6b29fb842026d1a5f3"</span>)}}}
)
</pre></td></tr></table></figure>













</li>
</ul>
]]></content>
    
    
      <category term="mongodb" scheme="http://snailsky.me/tags/mongodb/"/>
    
      <category term="mongo" scheme="http://snailsky.me/tags/mongo/"/>
    
      <category term="安装" scheme="http://snailsky.me/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="前端" scheme="http://snailsky.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="实践" scheme="http://snailsky.me/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="实践笔记" scheme="http://snailsky.me/categories/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 编程实践 - UI层的松耦合 (二)]]></title>
    <link href="http://snailsky.me/2014/06/07/javascript-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-ui%E5%B1%82%E7%9A%84%E6%9D%BE%E8%80%A6%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://snailsky.me/2014/06/07/javascript-编程实践-ui层的松耦合（二）/</id>
    <published>2014-06-07T07:46:17.000Z</published>
    <updated>2014-08-24T11:21:12.000Z</updated>
    <content type="html"><![CDATA[<p><em>这是一篇读书笔记，对书中的描述进行精简，归纳，总结，<br>有时也会自己写一些例子，感想和扩展 O(∩_∩)O~</em></p>
<hr>
<h2 id="5-将HTML从JavaScript中抽离">5.将HTML从JavaScript中抽离</h2>
<p>正如我们需要将JavaScript从HTML中抽离一样，最好也将HTML从JavaScript中抽离。避免HTML的问题被埋在JavaScript代码中，以节省调试时间。</p>
<h3 id="常见问题">常见问题</h3>
<p>在JavaScript中使用HTML的情形往往是给innerHTML属性赋值时，比如：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 不好的写法</span>
var <span class="keyword">div</span> = document.getElementById(<span class="string">"my-div"</span>);
<span class="keyword">div</span>.innerHTML = <span class="string">"&lt;h3&gt;Error&lt;/h3&gt;&lt;p&gt;Invalid e-mail address.&lt;/p&gt;"</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：将HTML嵌入JavaScript代码中是非常不好的实践。<br><strong>缺点</strong>：增加了跟踪文本和结构性问题的复杂度。追踪bug变得困难。<br>如果你希望修改文本或标签，你只希望去一个地方：可以控制你HTML代码的地方。如果你的标签出现在一处便可以很方便地更新它们。<br>相比于修改JavaScript代码，修改标签通常不会引发太多错误。当HTML和JavaScript混淆在一起时，问题将变得复杂。JavaScript字符串需要对引号做适当转义，这样则会导致它和模板语言的原生语法略有差异。</p>
<h3 id="解决方法">解决方法</h3>
<p>因为多数Web应用本质上都是动态的，需要通过JavaScript向页面插入或修改标签。有很多方法可以以低耦合方式完成这项工作。</p>
<h4 id="方式一：从服务器加载">方式一：从服务器加载</h4>
<p>将模板放置于远程服务器，使用XMLHttpRequest对象来获取外部标签。<br>例：点击一个链接，希望弹出一个新对话框，代码可能如下：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">loadDialog</span><span class="params">(name, oncomplete)</span>{</span>
    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
    xhr.open(<span class="string">"get"</span>, <span class="string">"/js/dialog"</span> + name, <span class="literal">true</span>);

    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> && xhr.status == <span class="number">200</span>) {
            <span class="keyword">var</span> div = document.getElementById(<span class="string">"dlg-holder"</span>);
            div.innerHTML = xhr.responseText;
            oncomplete();
        }<span class="keyword">else</span>{
            <span class="comment">// 处理错误</span>
        }
    }；
    xhr.send(<span class="literal">null</span>);
}
</pre></td></tr></table></figure>

<p><strong>评价</strong>：低耦合，对单页应用带来更多便捷。<br><strong>优点</strong>：这里没有将HTML字符串嵌入在JavaScript里，而是向服务器发起请求获取字符串，这样可以让HTML代码以最合适的方式注入到页面中。<br><strong>缺点</strong>：这种方法（从服务器获取模板）很容易造成XSS漏洞，需要服务器对模板文件做适当转义处理，比如&lt;和&gt;以及双引号等，当然前端也应当给出与之匹配的渲染规则，总之这种方法需要一揽子前后端的转码和解码策略来尽可能地封堵XSS漏洞。</p>
<p><strong>JavaScript类库</strong>将这个操作做了封装，使得直接给DOM元素挂在内容变得非常方便。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// YUI</span>
<span class="function"><span class="keyword">function</span> <span class="title">loadDialog</span><span class="params">(name, oncomplete)</span>{</span>
    <span class="transposed_variable">Y.</span>one(<span class="string">"#dlg-holder"</span>).<span class="built_in">load</span>(<span class="string">"/js/dialog/"</span> + name, oncomplete);
}
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// jQuery</span>
<span class="function"><span class="keyword">function</span> <span class="title">loadDialog</span><span class="params">(name, oncomplete)</span>{</span>
    $(<span class="string">"#dlg-holder"</span>).load(<span class="string">"/js/dialog/"</span> + name, oncomplete);
}
</pre></td></tr></table></figure>

<p><strong>适用时机</strong>：当你需要注入大段HTML标签到页面中时，使用远程调用的方式来加载标签是非常有帮助的。出于性能的原因，将大量没用的标签存放于内存或DOM中是很糟糕的做法。对于少量的标签段可以考虑采用客户端模板。</p>
<h4 id="方式二：简单客户端模板">方式二：简单客户端模板</h4>
<p>客户端模板是一些带“插槽”的标签片段，这些“插槽”会被JavaScript程序替换为数据以保证模板的完整可用。<br><em>比如：一段用来添加数据项的模板看起来就像下面这样。</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</pre></td></tr></table></figure>

<p>这段模板中包含%s占位符，这个位置的文本会被程序替换掉（这个格式和C语言中的sprintf（）一模一样）。JavaScript程序会将这些占位符替换为真实数据，然后将结果注入DOM。</p>
<p>那么<em>模板放在哪儿呢？</em><br>通常我们将模板定义在其他标签之间，直接存放于HTML页面里，这样可以被JavaScript读取，用以下两种方法之一可做到。</p>
<p><strong>模板位置一</strong>：在HTML注释中包含模板文本。</p>
<p>注释是和元素及文本一样的DOM节点，因此可以通过JavaScript将其提取出来。<br><em>完整实例如下</em>（书上的例子有些小问题，所以整理试了下，以下程序亲测可用）：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 简单客户端模板（模板位置一） - HTML代码 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span><span class="comment">&lt;!--&lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;--&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">//    简单客户端模板（模板位置一） - JavaScript代码</span>
<span class="comment">//    用参数替换占位符</span>
<span class="function"><span class="keyword">function</span> <span class="title">sprintf</span><span class="params">(text)</span>{</span>
    <span class="keyword">var</span> i=<span class="number">1</span>,args=<span class="built_in">arguments</span>;
    <span class="keyword">return</span> text.replace(<span class="regexp">/%s/g</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> (i &lt; args.length) ? args[i++] : <span class="string">""</span>;
    });
}
<span class="comment">//    将填充模板之后的结果添加到适当位置</span>
<span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">(url, text)</span>{</span>
    <span class="keyword">var</span> mylist = document.getElementById(<span class="string">"mylist"</span>),
        templateText = mylist.firstChild.nodeValue,
        <span class="comment">//templateText:  &lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;</span>
        result = sprintf(templateText,  url,  text);
    mylist.insertAdjacentHTML(<span class="string">"beforeend"</span>, result);
}
<span class="comment">//    用法</span>
addItem(<span class="string">"/item/4"</span>, <span class="string">"Fourth item"</span>);
</pre></td></tr></table></figure>

<p><em>笔记</em>：</p>
<ul>
<li><p>HTML代码中的注释部分一定要和上一级的开始标签挨着（此处就是注释和&lt;ul&gt;挨着），如果是像这样写</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 错误的写法 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span>
    <span class="comment">&lt;!--&lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;--&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var mylist = document<span class="preprocessor">.getElementById</span>(<span class="string">"mylist"</span>),
    templateText = mylist<span class="preprocessor">.firstChild</span><span class="preprocessor">.nodeValue</span><span class="comment">;</span>
</pre></td></tr></table></figure><br>将获取不到<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>insertAdjacentHTML方法：在指定的地方插入html标签语句<br>原型：insertAdajcentHTML(swhere,stext)<br>参数：swhere: 指定插入html标签语句的地方，有四种值可用：</p>
</li>
</ul>
<ol>
<li>beforeBegin: 插入到标签开始前</li>
<li>afterBegin:插入到标签开始标记之后</li>
<li>beforeEnd:插入到标签结束标记前</li>
<li>afterEnd:插入到标签结束标记后</li>
</ol>
<p><strong>模板位置二</strong>：放在一个带有自定义type属性的&lt;script&gt;元素。</p>
<p>浏览器会默认将&lt;script&gt;元素中的内容识别为JavaScript代码，但你可以通过给type赋值为浏览器不识别的类型，来告诉浏览器这不是一段JavaScript脚本。</p>
<p><em>完整实例如下</em>：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 简单客户端模板（模板位置二） - HTML代码 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>//    简单客户端模板（模板位置二） - 模板写在script元素中
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-my-template"</span> <span class="attribute">id</span>=<span class="value">"list-item"</span>&gt;</span><span class="javascript">
    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">//    简单客户端模板（模板位置二） - JavaScript代码</span>
<span class="comment">//    用参数替换占位符</span>
<span class="function"><span class="keyword">function</span> <span class="title">sprintf</span><span class="params">(text)</span>{</span>
    <span class="keyword">var</span> i=<span class="number">1</span>,args=<span class="built_in">arguments</span>;
    <span class="keyword">return</span> text.replace(<span class="regexp">/%s/g</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> (i &lt; args.length) ? args[i++] : <span class="string">""</span>;
    });
}
<span class="comment">//    将填充模板之后的结果添加到适当位置</span>
<span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">(url, text)</span>{</span>
    <span class="keyword">var</span> mylist = document.getElementById(<span class="string">"mylist"</span>),
        script = document.getElementById(<span class="string">"list-item"</span>),
        templateText = script.text,
        result = sprintf(templateText,  url,  text),
        div = document.createElement(<span class="string">"div"</span>);

    div.innerHTML = result.replace(<span class="regexp">/^\s*/</span>, <span class="string">""</span>);
    mylist.appendChild(div.firstChild);
}
<span class="comment">//    用法</span>
addItem(<span class="string">"/item/4"</span>, <span class="string">"Fourth item"</span>);
</pre></td></tr></table></figure>

<p><em>笔记</em>：</p>
<ul>
<li>函数中去掉了模板文本中的前导空格<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>result.<span class="operator"><span class="keyword">replace</span>(/^\s*/, <span class="string">""</span>);</span>
</pre></td></tr></table></figure><br>之所以会出现这个多余的前导空格，是因为模板文本总是在 &lt;script&gt;起始标签的下一行。如果将模板文本原样注入，则会在 &lt;div&gt;里创建一个文本结点，这个文本节点的内容是一个空格，而这个文本节点最终会代替 &lt;li&gt;被添加进列表之中。</li>
</ul>
<h4 id="方式三：复杂客户端模板">方式三：复杂客户端模板</h4>
<p>前两种方式模板格式都非常简单，无太多转义，如果想用一些更健壮的模板，可以考虑诸如<a href="http://handlebarsjs.com/" target="_blank">Handlebars</a>所提供的解决方案。</p>
<p>Handlebars是专为浏览器端JavaScript设计的完整的客户端模板系统。<br>在Handlebars的模板中，占位符使用双花括号来表示。</p>
<p><em>上一节中的模板Handlebars版本完整实例如下</em>：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 复杂客户端模板（Handlebars） - HTML代码 --&gt;</span>
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"mylist"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/2"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/item/3"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>//    复杂客户端模板（Handlebars） - 模板写在script元素中
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-handlebars-template"</span> <span class="attribute">id</span>=<span class="value">"list-item"</span>&gt;</span><span class="javascript">
    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">""</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>//    复杂客户端模板（Handlebars） - JavaScript代码
function addItem(url, text){
    var mylist = document<span class="preprocessor">.getElementById</span>(<span class="string">"mylist"</span>),
        script = document<span class="preprocessor">.getElementById</span>(<span class="string">"list-item"</span>),
        templateText = script<span class="preprocessor">.text</span>,
        template = Handlebars<span class="preprocessor">.compile</span>(templateText),
        div = document<span class="preprocessor">.createElement</span>(<span class="string">"div"</span>),
        result<span class="comment">;</span>

        <span class="comment">/* 变量template包含了一个函数，当执行这个函数时则返回一个
        格式化好的字符串，你需要做的仅仅是传入一个包含属性的对象，
        参数会自动做HTML转义。*/</span>
        result = template({
            text:text,
            url:url
        })<span class="comment">;</span>
    div<span class="preprocessor">.innerHTML</span> = result<span class="comment">;</span>
    mylist<span class="preprocessor">.appendChild</span>(div<span class="preprocessor">.firstElementChild</span>)<span class="comment">;</span>
}
//    用法
addItem(<span class="string">"/item/4"</span>, <span class="string">"Fourth item"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p><em>笔记</em>：</p>
<ul>
<li><p>要使用Handlebars首先要将Handlebars类库引入页面。这个类库会创建一个名为Handlebars的全局变量，用来将模板文本编译为一个函数。<br>我是用的 bower 来安装 Handlebars 的：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>bower <span class="keyword">install</span> handlebars -g
</pre></td></tr></table></figure><br>(注：Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。)<br>安装后记得引用进页面来：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/javascripts/handlebars.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>在Handlebars模板中，占位符都记为一个名称，以便可以在JavaScript中设计其映射。Handlebars 建议将模板嵌入 HTML 页面中，并使用 type 属性为 “text/x-handlebars-template”的&lt;script&gt;标签来表示（如上例所示）</p>
</li>
<li><p>变量template包含了一个函数，当执行这个函数时则返回一个格式化好的字符串，你需要做的仅仅是传入一个包含属性的对象。参数会自动做HTML转义，转义操作也是格式化的一部分。转义是为了增强模板的安全性，并确保简单的文本值不会破坏你的标签结构。比如，字符”&amp;”会自动转义为 “&amp;amp”;</p>
</li>
<li><p>关于上面例子的写法，最初我尝试用之前的写法：<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>mylist<span class="preprocessor">.appendChild</span>(div<span class="preprocessor">.firstChild</span>)<span class="comment">;</span>
</pre></td></tr></table></figure><br>可是无效，我又打印出div看，div 的 firstChild 确实是li，可是打印 div.firstChild 出来是“#text”它的值貌似是个回车。我发现打印div下有个 firstElementChild 和 firstChild 里面的东西一样的所以就用 firstElementChild 试了，还真可以，不过还是不懂为什么firstChild不行了，大家如果知道原因，求指点。</p>
</li>
</ul>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="书" scheme="http://snailsky.me/tags/%E4%B9%A6/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 编程实践 - UI层的松耦合 (一)]]></title>
    <link href="http://snailsky.me/2014/05/31/javascript-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-UI%E5%B1%82%E7%9A%84%E6%9D%BE%E8%80%A6%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://snailsky.me/2014/05/31/javascript-编程实践-UI层的松耦合（一）/</id>
    <published>2014-05-31T03:33:37.000Z</published>
    <updated>2014-08-24T11:21:12.000Z</updated>
    <content type="html"><![CDATA[<p><em>这是一篇读书笔记，对书中的描述进行精简，归纳，总结，<br>有时也会自己写一些例子，感想和扩展 O(∩_∩)O~</em></p>
<hr>
<h1 id="UI层的松耦合">UI层的松耦合</h1>
<p>WEB开发中 UI由三个彼此隔离又相互作用的层定义（HTML,CSS,JavaScript）。</p>
<p>在实际场景中，css和JavaScript是同等重要的，两者更像是兄弟关系并非依赖关系（javascript依赖css）。<br>一个页面很可能只有HTML和CSS而没有JavaScript,<br>或………………只有HTML和JavaScript而没有CSS。</p>
<p>在所有Web UI中，JavaScript的正确运行不应依赖CSS—在缺少CSS情况下也要能够正确运行，尽管两者之间可能有互动。</p>
<h2 id="1-_什么是松耦合">1. 什么是松耦合</h2>
<h3 id="1-1_什么是耦合：">1.1 什么是耦合：</h3>
<p>如果两个组件耦合太紧，则说明一个组件和另一个组件直接相关，<br>如果修改一个组件的逻辑，那么另外一个组件的逻辑也需修改。</p>
<p>耦合的例子：有一个贯穿整个站点的css类叫做error，被嵌入到HTML中。如果有一天你要改error这个名字为warning，不仅要修改CSS还要修改用到这个类名的HTML，HTML和CSS紧耦合在一起。</p>
<h3 id="1-2_什么时候才能称作松耦合：">1.2 什么时候才能称作松耦合：</h3>
<p>当你能够做到修改一个组件而不需要更改其他组件时，你就做到了松耦合。</p>
<p>松耦合是易于调试的，这对于代码的可维护性来说至关重要。修改某部分代码是不会破坏其他人的代码，那便是极好的 0.0’</p>
<p>在一起工作的组件无法达到“无耦合”，我们的目标是确保对一个组件的修改不会经常性地影响其他部分。</p>
<h2 id="2-_将JavaScript从CSS中抽离">2. 将JavaScript从CSS中抽离</h2>
<p>IE8和更早版本的浏览器中有一个特性让人爱少恨多，即CSS表达式（CSS expression）。<br>CSS表达式允许你将JavaScript直接插入到CSS中，可以在CSS代码中直接执行运算或其他操作。</p>
<p><em>设置元素宽度以匹配浏览器宽度</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/* 不好的写法 */</span>
<span class="class">.box</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="function">expression(document.body.offsetWidth + <span class="string">"px"</span>)</span></span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>CSS表达式包裹在一个特殊的expression()函数中，可以给它传入任意JavaScript代码。<br>浏览器会以高频率重复计算CSS表达式，严重影响了性能。且难以维护。<br>IE9不再支持CSS表达式，老版本IE依然可以运行CSS表达式。<br>有人会用CSS表达式来让低版本浏览器里也达到和高级浏览器一致的表现，但尽量避免使用，以避免浪费不必要的时间精力。</p>
<p><strong>总结</strong>：避免使用CSS表达式</p>
<h2 id="3-_将CSS从JavaScript中抽离">3. 将CSS从JavaScript中抽离</h2>
<p>CSS和JavaScript互相协作的很不错，所以我们经常将样式数据和JavaScript混写在一起。</p>
<h3 id="JavaScript改CSS方式：">JavaScript改CSS方式：</h3>
<h4 id="方式一（不好）：style属性">方式一（不好）：style属性</h4>
<p>直接修改DOM元素的style属性。</p>
<p>style属性是一个对象，包含了可以读取和修改的CSS属性。<br><em>如：修改元素文本颜色</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 不好的写法 */</span>
element<span class="preprocessor">.style</span><span class="preprocessor">.color</span> = <span class="string">"red"</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：这种写法经常看到，但是这种写法是有问题的。<br><strong>缺点</strong>：当出现样式问题，通常首先去查找CSS，而非JavaScript，浪费时间。<br><strong>例外</strong>：有一种使用style属性的情形是可以接受的:<br>当你需要给页面中的元素作定位，使其相对于另外一个元素或整个页面重新定位。这种计算在CSS中无法完成，<br>此时可以使用style.top、style.left、style.bottom、style.right 来对元素作正确定位。<br>在CSS中定义这个元素的默认属性，而在JavaScript中修改这些默认值。</p>
<h4 id="方式二（不好）：cssText属性">方式二（不好）：cssText属性</h4>
<p>给cssText属性赋值整个CSS字符串</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 不好的写法 */</span>
element<span class="preprocessor">.style</span><span class="preprocessor">.cssText</span> = <span class="string">"color: red; left: 10px; top: 100px; visibility: hidden"</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：这种写法是一次性设置多个CSS属性的一种快捷方法，同样有问题。<br><strong>缺点</strong>：比如设置单个属性时：将样式信息写入JavaScript带来了可维护性问题。</p>
<h4 id="方式三（最佳）：操作className">方式三（最佳）：操作className</h4>
<p>操作CSS的className</p>
<p><em>例：在页面中显示一个对话框，css中的样式定义像下面这样</em></p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="class">.reveal</span><span class="rules">{
    <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">10</span>px</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100</span>px</span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> visible</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure><br><em>在JavaScript中像这样将样式添加至元素。</em><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - 原生方法 */</span>
element<span class="preprocessor">.className</span> += <span class="string">" reveal"</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - HTML5 */</span>
element<span class="preprocessor">.classList</span><span class="preprocessor">.add</span>(<span class="string">"reveal"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - YUI */</span>
<span class="built_in">Y</span><span class="preprocessor">.one</span>(element)<span class="preprocessor">.addClass</span>(<span class="string">"reveal"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - jQuery */</span>
$(element).addClass(<span class="string">"reveal"</span>);
</pre></td></tr></table></figure>

<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">/* 好的写法 - Dojo */</span>
dojo<span class="preprocessor">.addClass</span>(element, <span class="string">"reveal"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：JavaScript可以随意添加删除元素的className，而className定义的样式则在CSS代码中。<br>CSS样式随时可以修改，而不必更新JavaScript。<br><strong>优点</strong>：JavaScript未直接操作样式，保持了和CSS的松耦合。</p>
<h2 id="4-将JavaScript从HTML中抽离">4.将JavaScript从HTML中抽离</h2>
<p>很多人学习JavaScript之初所做的第一件事是，将脚本嵌入HTML中来运行。</p>
<h3 id="绑定事件方式">绑定事件方式</h3>
<h4 id="方式一_（不好）：使用on属性">方式一 （不好）：使用on属性</h4>
<p>使用on属性（ 比如onclick ）绑定一个事件处理程序</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不好的写法 --&gt;</span>
<span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"doSomething()"</span> <span class="attribute">id</span>=<span class="value">"action-btn"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：此写法2000年时非常流行，尽管这种代码多数场景下是正常工作的，但却是两个UI层（HTML和JavaScript）的深耦合，这种写法有一些问题<br><strong>缺点</strong>：</p>
<ol>
<li>点击事件发生时，doSomething()函数必须存在，否则会报JavaScript错误，页面或弹出错误信息或点击事件不会有任何响应。</li>
<li>如果修改了doSomething()的函数名或如果此时点击按钮调用了其他函数，需要同时修改JavaScript和HTML代码。给维护带来了困难，这是典型的紧耦合的代码。</li>
</ol>
<h4 id="方式二（最佳）：_通过&lt;script&gt;标签来引用">方式二（最佳）： 通过&lt;script&gt;标签来引用</h4>
<p>绝大多数（并非所有的）JavaScript代码包含在外部文件中，并在页面中通过&lt;script&gt;标签来引用。<br>对于支持2级DOM模型的浏览器来说，用下代码可完成上面例子中的功能：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span>{</span>
    <span class="comment">//代码</span>
}
<span class="keyword">var</span> btn = document.getElementById(<span class="string">"action-btn"</span>);
btn.addEventListener(<span class="string">"click"</span>, doSomething, <span class="literal">false</span>);
</pre></td></tr></table></figure><br><strong>关于addEventListener()函数</strong>：<br>IE8及其更早的版本不支持addEventListener()函数，因此需要一个标准的函数将这些差异性做封装。<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">/*
 * 这个函数可以做到在各种浏览器中给一个元素添加事件处理程序
 * 甚至可以降级到支持给0级DOM模型对象的on属性赋值处理程序
 * （只有在非常古老的浏览器），比如Netscape4中，才会执行这一步，
 * 因此这段代码可以在所有情形下都正常工作）
 */</span>
<span class="keyword">function</span> addListener(target, <span class="class"><span class="keyword">type</span>, <span class="title">handler</span>){</span>
    <span class="keyword">if</span>(target.addEventListener){
        target.addEventListener(<span class="class"><span class="keyword">type</span>, <span class="title">handler</span>, <span class="title">false</span>);</span>
    }<span class="keyword">else</span> <span class="keyword">if</span>(target.attachEvent){
    		target.attachEvent(<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>, <span class="title">handler</span>);</span>
    }<span class="keyword">else</span>{
        target[<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>] =</span> handler;
    }
}
</pre></td></tr></table></figure><br>我们常常像下面这样来使用这个方法<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span>{</span>
    <span class="comment">//代码</span>
}
<span class="keyword">var</span> btn = document.getElementById(<span class="string">"action-btn"</span>);
addListener(btn, <span class="string">"click"</span>, doSomething);
</pre></td></tr></table></figure><br>如果你用了 <strong>JavaScript 类库</strong>，可以使用类库提供的方法来给元素挂载事件处理程序<br>这里给出一些流行类库中的实例代码。<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>// YUI
<span class="built_in">Y</span><span class="preprocessor">.one</span>(<span class="string">"#action-btn"</span>)<span class="preprocessor">.on</span>(<span class="string">"click"</span>, doSomething)<span class="comment">;</span>
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// jQuery</span>
$(<span class="string">"#action-btn"</span>).on(<span class="string">"click"</span>, doSomething);
</pre></td></tr></table></figure><br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// Dojo</span>
<span class="keyword">var</span> btn = dojo.byId(<span class="string">"action-btn"</span>);
dojo.connect(btn, <span class="string">"click"</span>, doSomething);
</pre></td></tr></table></figure>

<p><strong>评价</strong>：优势在于，函数doSomething()的定义和事件处理程序绑定都是在一个文件中完成的。如果函数名称需要修改，则只需修改一个文件；<br>如果点击事件发生时想额外做些动作，也只需在一处做修改。<br><strong>优点</strong>：不需同时修改多个文件，可维护性提高，实现了松耦合。</p>
<h4 id="方式三_（不好）：HTML中内联的脚本代码">方式三 （不好）：HTML中内联的脚本代码</h4>
<p>在HTML中使用&lt;script&gt;标签，标签内包含内联的脚本代码。</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不好的写法 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    doSomething();
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p><strong>评价</strong>：最好将所有JavaScript代码都放入外置文件中，以确保在HTML代码中不会有内联的JavaScript代码，利于调试。<br><strong>缺点</strong>：不利于确信（而非猜测）从何下手调试bug</p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://snailsky.me/tags/JavaScript/"/>
    
      <category term="笔记" scheme="http://snailsky.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="书" scheme="http://snailsky.me/tags/%E4%B9%A6/"/>
    
      <category term="JavaScript" scheme="http://snailsky.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello My Blog]]></title>
    <link href="http://snailsky.me/2014/05/18/hello-my-blog/"/>
    <id>http://snailsky.me/2014/05/18/hello-my-blog/</id>
    <published>2014-05-18T14:50:49.000Z</published>
    <updated>2014-08-24T05:58:00.000Z</updated>
    <content type="html"><![CDATA[<p>这是<strong>我的blog </strong>，我正在创建第一篇日志。<br>今后的博客的测试什么的也将在这篇博客里尝试~</p>
<p>我要在这开始我的博客之旅咯…………</p>
<p>我还是要在测试一下…</p>
<p>最重要的代码神马的这样写…</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(<span class="string">"hello world"</span>);
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="日记" scheme="http://snailsky.me/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="http://snailsky.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="生活随笔" scheme="http://snailsky.me/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
